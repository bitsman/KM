<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>操作系统</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="操作系统"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2016-09-14 13:08:24 中国标准时间"/>
<meta name="author" content="比克曼"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<link rel='stylesheet' type='text/css' href='css/org-manual.css' />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">操作系统</h1>




<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 基本概念</a>
<ul>
<li><a href="#sec-1-1">1.1 进程</a></li>
<li><a href="#sec-1-2">1.2 线程</a></li>
<li><a href="#sec-1-3">1.3 信号量</a></li>
</ul>
</li>
<li><a href="#sec-2">2 linux</a>
<ul>
<li><a href="#sec-2-1">2.1 shell</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1 grep</a></li>
<li><a href="#sec-2-1-2">2.1.2 find</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 android</a>
<ul>
<li><a href="#sec-3-1">3.1 base</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1 Bundle</a></li>
<li><a href="#sec-3-1-2">3.1.2 Intent</a></li>
<li><a href="#sec-3-1-3">3.1.3 系统时间</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2 activity</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1 Fragment</a></li>
<li><a href="#sec-3-2-2">3.2.2 button</a></li>
<li><a href="#sec-3-2-3">3.2.3 下拉菜单</a></li>
<li><a href="#sec-3-2-4">3.2.4 复选框</a></li>
<li><a href="#sec-3-2-5">3.2.5 单选框</a></li>
<li><a href="#sec-3-2-6">3.2.6 对话框</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3 service</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1 Bound Service</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4 broadcast</a></li>
<li><a href="#sec-3-5">3.5 消息机制</a>
<ul>
<li><a href="#sec-3-5-1">3.5.1 Handler</a></li>
<li><a href="#sec-3-5-2">3.5.2 Looper</a></li>
<li><a href="#sec-3-5-3">3.5.3 Message</a></li>
<li><a href="#sec-3-5-4">3.5.4 SharedPreferences</a></li>
</ul>
</li>
<li><a href="#sec-3-6">3.6 通知栏操作</a></li>
<li><a href="#sec-3-7">3.7 程序首选项</a></li>
<li><a href="#sec-3-8">3.8 menu</a></li>
<li><a href="#sec-3-9">3.9 gps</a>
<ul>
<li><a href="#sec-3-9-1">3.9.1 组件</a></li>
<li><a href="#sec-3-9-2">3.9.2 操作</a>
<ul>
<li><a href="#sec-3-9-2-1">3.9.2.1 LocationManager</a></li>
<li><a href="#sec-3-9-2-2">3.9.2.2 LocationListener</a></li>
<li><a href="#sec-3-9-2-3">3.9.2.3 Location</a></li>
<li><a href="#sec-3-9-2-4">3.9.2.4 GpsStatus.Listener</a></li>
<li><a href="#sec-3-9-2-5">3.9.2.5 GpsStatus</a></li>
<li><a href="#sec-3-9-2-6">3.9.2.6 GpsSatellite</a></li>
</ul>
</li>
<li><a href="#sec-3-9-3">3.9.3 位置模拟</a></li>
</ul>
</li>
<li><a href="#sec-3-10">3.10 bt</a>
<ul>
<li><a href="#sec-3-10-1">3.10.1 概念</a></li>
<li><a href="#sec-3-10-2">3.10.2 蓝牙权限</a></li>
<li><a href="#sec-3-10-3">3.10.3 设置蓝牙</a></li>
<li><a href="#sec-3-10-4">3.10.4 寻找设备</a></li>
<li><a href="#sec-3-10-5">3.10.5 轮询已配对的设备</a></li>
<li><a href="#sec-3-10-6">3.10.6 搜索设备</a></li>
<li><a href="#sec-3-10-7">3.10.7 使能可发现性</a></li>
<li><a href="#sec-3-10-8">3.10.8 连接设备</a></li>
<li><a href="#sec-3-10-9">3.10.9 服务端的连接</a></li>
<li><a href="#sec-3-10-10">3.10.10 客户端的连接</a></li>
<li><a href="#sec-3-10-11">3.10.11 管理连接</a></li>
<li><a href="#sec-3-10-12">3.10.12 使用Profiles</a></li>
<li><a href="#sec-3-10-13">3.10.13 制造商自定义AT指令</a></li>
<li><a href="#sec-3-10-14">3.10.14 健康设备Profile</a></li>
</ul>
</li>
<li><a href="#sec-3-11">3.11 ble</a></li>
<li><a href="#sec-3-12">3.12 sensor</a>
<ul>
<li><a href="#sec-3-12-1">3.12.1 传感器类型</a></li>
<li><a href="#sec-3-12-2">3.12.2 使用方法</a></li>
</ul>
</li>
<li><a href="#sec-3-13">3.13 jni</a></li>
</ul>
</li>
<li><a href="#sec-4">4 rtos</a>
<ul>
<li><a href="#sec-4-1">4.1 FreeRTOS</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1 术语</a></li>
<li><a href="#sec-4-1-2">4.1.2 源码解读</a>
<ul>
<li><a href="#sec-4-1-2-1">4.1.2.1 文件</a>
<ul>
<li><a href="#sec-4-1-2-1-1">4.1.2.1.1 FreeRTOS.h</a></li>
<li><a href="#sec-4-1-2-1-2">4.1.2.1.2 projdefs.h</a></li>
<li><a href="#sec-4-1-2-1-3">4.1.2.1.3 FreeRTOSConfig.h</a></li>
<li><a href="#sec-4-1-2-1-4">4.1.2.1.4 portable.h</a></li>
</ul>
</li>
<li><a href="#sec-4-1-2-2">4.1.2.2 功能函数</a>
<ul>
<li><a href="#sec-4-1-2-2-1">4.1.2.2.1 任务生成</a></li>
<li><a href="#sec-4-1-2-2-2">4.1.2.2.2 任务删除</a></li>
<li><a href="#sec-4-1-2-2-3">4.1.2.2.3 堆操作</a></li>
<li><a href="#sec-4-1-2-2-4">4.1.2.2.4 杂项功能</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 基本概念</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 进程</h3>
<div class="outline-text-3" id="text-1-1">

<p>一个进程代表一个任务，多进程也就是多任务，一个进程包含运行所需的资源，包含
运行代码，内存空间，栈空间，外设资源等。在Windows中一个应用程序就是一个进程。
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 线程</h3>
<div class="outline-text-3" id="text-1-2">

<p>在一定程度上进程的原理和线程一样。每个进程都有一个PCB块记录进程的各种资源信
息，线程一般也有。线程是进程的功能子集，一个进程可以包含多个线程，多个线程
协作完成进程的任务，一般线程所需资源有代码和栈空间，其中栈空间用于记录线程
切换时自己的上下文，所以比起进程概念比较"轻"，CPU在上下文切换时更快捷方便.<br/>
一般的嵌入式操作系统实现的是单进程下多线程，用一个上下文调度器进行线程切换。
如果要实现多进程，估计需要多个调度器，多个调度器再协作，或者在一个调度器中
控制多个进程的资源和代码以及线程功能（个人猜想）。
</p></div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 信号量</h3>
<div class="outline-text-3" id="text-1-3">

<p>信号量用于记录临界资源的个数，当多个线程试图访问这些资源时，每访问一个资源
信号量减1，也就是传说中的P操作，每访问完一个资源，将释放信号量加1，也就是传
说中的V操作，当信号量减为1时，这个资源变成临界区资源，如果信号量减为0后，新
申请资源的线程将被挂起。<br/>
信号量实现的一种简单方式，就是设置1个整数变量和指向资源的指针的结构体，在线
程访问这个变量时，关闭所有的中断和异常，然后对变量进行加1或者减1，实现信号
量的访问。  
</p></div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> linux</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> shell</h3>
<div class="outline-text-3" id="text-2-1">


</div>

<div id="outline-container-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> grep</h4>
<div class="outline-text-4" id="text-2-1-1">

<ul>
<li>用法：grep [-acinv]  [&ndash;color=auto] '搜索关键词' filename
<ol>
<li>-a，将 binary 文件以 text 文件的方式搜寻数据; 
</li>
<li>-c，计算找到 '搜寻字符串' 的次数;
</li>
<li>-i，忽略大小写的不同，所以大小写视为相同;
</li>
<li>-n，顺便输出行号;
</li>
<li>-v，反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行;
</li>
<li>&ndash;color=auto，可以将找到的关键词部分加上颜色的显示喔！
</li>
</ol>

</li>
<li>用例：
<ol>
<li>在当前目录下找到所有文件中包含关键字Scd的行



<pre class="example">cat * | grep -n Scd
</pre>

</li>
</ol>

</li>
</ul>

</div>

</div>

<div id="outline-container-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> find</h4>
<div class="outline-text-4" id="text-2-1-2">

<ul>
<li>用法：过于复杂；
</li>
<li>用例：
<ol>
<li>在当前目录下找到所有（包括子目录）文件名后缀是".c", ".h"的文件名路径并
     输出到文件cscope.files



<pre class="example">find . -name "*.[ch]" &gt;cscope.files
</pre>

</li>
</ol>

</li>
</ul>

</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> android</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> base</h3>
<div class="outline-text-3" id="text-3-1">

<ul>
<li>上下文context
<ul>
<li>getApplicationContext():生命周期是整个应用，应用摧毁，它才摧毁。
</li>
<li>this:代表当前,在Activity当中就是代表当前的Activity，换句话说就是 
    Activity.this在Activity当中可以缩写为this. 
</li>
<li>getApplication():andorid 开发中共享全局数据;
</li>
</ul>

<p>  我们在平时的开发中，有时候可能会需要一些全局数据，来让应用中得所有
  Activity和View都能访问到，大家在遇到这种情况时，可能首先会想到自己定义一
  个类，然后创建很多静态成员，不过andorid已经为我们提供了这种情况的解决方案：
  在Android中，有一个名为Application的类，我们可以在Activity中使用
  getApplication()，方法来获得，它是代表我们的应用程序的类，使用它可以获得
  当前应用的主题，资源文件中的内容等，这个类更灵活的一个特性就是可以被我们
  继承，来添加我们自己的全局属性。  
</p></li>
<li>判断当前Activity



<pre class="example">ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
ComponentName cn = am.getRunningTasks(1).get(0).topActivity;
Log.d(TAG, "pkg:"+cn.getPackageName());//显示当前activity所在路径
Log.d(TAG, "cls:"+cn.getClassName());//路径+类名
Log.d(TAG, MyActivity.class.getName()); //路径+类名
Log.d(TAG, MyActivity.class.getSimpleName()); //类名
</pre>

</li>
</ul>


</div>

<div id="outline-container-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Bundle</h4>
<div class="outline-text-4" id="text-3-1-1">

<p>android中的Bundle一般用于携带数据，类似于Map，用于存放key-value键值对，其提
供了各种putXx()和getXx()方法，putXx()用于往Bundle对象中放入数据，getXx()用
于从Bundle对象中获取数据。比如Bundle常用与组件之间进行数据传输，我们可以将
Bundle设置好数据后，利用Intent的putExtras()方法将Bundle捆绑到Intent中，然后
再传递给别的组件； 
</p></div>

</div>

<div id="outline-container-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Intent</h4>
<div class="outline-text-4" id="text-3-1-2">

<p>Intent可以用于启动别的组件比如Activity和Service等，并在Intent中绑定一定的数
据，传递给目标组件。 
</p></div>

</div>

<div id="outline-container-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> 系统时间</h4>
<div class="outline-text-4" id="text-3-1-3">

<ul>
<li>获取年月日



<pre class="example">import    java.text.SimpleDateFormat;     
SimpleDateFormat formatter = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");     
Date curDate = new Date(System.currentTimeMillis());//获取当前时间     
String str = formatter.format(curDate);     
</pre>

</li>
<li>获取当前的年月时分



<pre class="example">SimpleDateFormat sDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");     
String date = sDateFormat.format(new java.util.Date());  
</pre>

</li>
<li>获取当前的年月



<pre class="example">SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM");  
String date=sdf.format(new java.util.Date());  
</pre>

</li>
<li>获取指定时区的时间



<pre class="example">df = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);
System.out.println(df.format(new Date()));
</pre>

</li>
<li>确定系统时间制式



<pre class="example">ContentResolver cv = this.getContentResolver();
String strTimeFormat = android.provider.Settings.System.getString(cv,
                                                       android.provider.Settings.System.TIME_12_24);
if(strTimeFormat.equals("24")){
   Log.i("activity","24");
}
</pre>

</li>
<li>取得系统时间日期



<pre class="example">Calendar c = Calendar.getInstance();
year = c.get(Calendar.YEAR) /*取得系统日期*/
month = c.grt(Calendar.MONTH)
day = c.get(Calendar.DAY_OF_MONTH)
hour = c.get(Calendar.HOUR_OF_DAY);/*取得系统时间*/
minute = c.get(Calendar.MINUTE)
</pre>

</li>
<li>利用TIMER获取



<pre class="example">Time t=new Time(); // or Time t=new Time("GMT+8"); 加上Time Zone资料。
t.setToNow(); // 取得系统时间。
int year = t.year;
int month = t.month;
int date = t.monthDay;
int hour = t.hour; // 0-23
int minute = t.minute;
int second = t.second;
</pre>

</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> activity</h3>
<div class="outline-text-3" id="text-3-2">


</div>

<div id="outline-container-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> Fragment</h4>
<div class="outline-text-4" id="text-3-2-1">

<p>Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。针对屏
幕尺寸的差距，很多情况下，都是先针对手机开发一套App，然后拷贝一份，修改布局
以适应平板神马超级大屏的。难道无法做到一个App可以同时适应手机和平板么，当然
了，必须有啊。Fragment的出现就是为了解决这样的问题。你可以把Fragment当成
Activity的一个界面的一个组成部分，甚至Activity的界面可以完全有不同的
Fragment组成，更帅气的是Fragment拥有自己的生命周期和接收、处理用户的事件，
这样就不必在Activity写一堆控件的事件处理的代码了。更为重要的是，你可以动态
的添加、替换和移除某个Fragment; Fragment必须是依存与Activity而存在的，因此
Activity的生命周期会直接影响到Fragment的生命周期, Fragment的生命周期见图
<a href="#img-fragment-cycle">img-fragment-cycle</a>;  
</p>


<div id="img-fragment-cycle" class="figure">
<p><img src="./img/img-fragment-cycle.png"  alt="./img/img-fragment-cycle.png" /></p>
<p>Fragment生命周期</p>
</div>

</div>

</div>

<div id="outline-container-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> button</h4>
<div class="outline-text-4" id="text-3-2-2">

<ul>
<li>button透明：xml中使用android:background="@android:color/transparent"
</li>
</ul>

</div>

</div>

<div id="outline-container-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> 下拉菜单</h4>
<div class="outline-text-4" id="text-3-2-3">

<p>实现某个菜单框里面有多个选项，点击后可以展示各个字符菜单项，点击后可以产生
点击事件，可以将某个int值和字符菜单项对应；实现方法： 
</p><ol>
<li>定义两个array资源：



<pre class="example">//字符菜单项
&lt;string-array name="gps_type_options"&gt;
    &lt;item&gt;GPS&lt;/item&gt;
    &lt;item&gt;GPS and GLONASS&lt;/item&gt;
    &lt;item&gt;GPS and BEIDOU&lt;/item&gt;
&lt;/string-array&gt;
</pre>


<pre class="example">//int对应值
&lt;integer-array name="gps_type_values"&gt;
    &lt;item&gt;0&lt;/item&gt;
    &lt;item&gt;1&lt;/item&gt;
    &lt;item&gt;2&lt;/item&gt;
&lt;/integer-array&gt;
</pre>

</li>
<li>xml中定义器件



<pre class="example">&lt;Spinner
    android:id="@+id/spinnerType"
    android:layout_width="0dip"
    android:layout_height="wrap_content"
    android:layout_marginRight="8dip"
    android:layout_weight="1" /&gt;
</pre>

</li>
<li>在源文件中获取这2个资源：



<pre class="example">String[] gpsTypeOptions = getResources().getStringArray(R.array.gps_type_options);
int[] gpsTypeValues = getResources().getIntArray(R.array.gps_type_values);
</pre>

</li>
<li>绑定两者成adapter:



<pre class="example">private IntArrayAdapter mGPSTypeAdapter;
mGPSTypeAdapter = new IntArrayAdapter(this, gpsTypeOptions, gpsTypeValues);
</pre>

</li>
<li>将adapter装配到view上：



<pre class="example">private Spinner mSpinnerType;
mSpinnerType = (Spinner) findViewById(R.id.spinnerType);
mSpinnerType.setAdapter(mGPSTypeAdapter);
mSpinnerType.setOnItemSelectedListener(onItemSelectedListener);
</pre>

</li>
<li>实现点击事件：



<pre class="example">private OnItemSelectedListener onItemSelectedListener = new OnItemSelectedListener() {
    @Override
    public void onItemSelected(AdapterView&lt;?&gt; adapter,View view,int position,long id) {
        if (adapter == mSpinnerType) {
            mGPSTypePostion = position;
        }
    }
    @Override
    public void onNothingSelected(AdapterView&lt;?&gt; arg0) {}
};
</pre>

</li>
</ol>

</div>

</div>

<div id="outline-container-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> 复选框</h4>
<div class="outline-text-4" id="text-3-2-4">

<p>正方形的复选框选项
</p><ol>
<li>xml中定义器件



<pre class="example">&lt;CheckBox 
  android:id="@+id/cb"
  android:layout_width="wrap_content" 
  android:layout_height="wrap_content"
  android:checked="false"
  android:text="已婚" /&gt;
</pre>

</li>
<li>源码中获取器件



<pre class="example">private CheckBox mCheckKeep;
mCheckKeep = (CheckBox) findViewById(R.id.checkKeep);

</pre>

</li>
<li>监听事件



<pre class="example">//绑定监听器
cb.setOnCheckedChangeListener(new OnCheckedChangeListener() {
    @Override
    public void onCheckedChanged(CompoundButton arg0, boolean arg1) {
        Toast.makeText(MyActivity.this, 
         arg1?"选中了":"取消了选中"    , Toast.LENGTH_LONG).show();
   }
 });
</pre>

</li>
<li>也可以查询获得结果



<pre class="example">if(!cb.isChecked()){
}
</pre>

</li>
</ol>

</div>

</div>

<div id="outline-container-3-2-5" class="outline-4">
<h4 id="sec-3-2-5"><span class="section-number-4">3.2.5</span> 单选框</h4>
<div class="outline-text-4" id="text-3-2-5">

<p>单选框可以将多个选项汇聚到一个组中，这个组中的每个单选项是互斥的，选一个其 
他的就不能选。
</p><ul>
<li>xml文件



<pre class="example">&lt;RadioGroup
    android:id="@+id/shoes_sel"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_x="3px"
    android:layout_y="54px" &gt;
    &lt;RadioButton
        android:id="@+id/RadioButton1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="工厂测试"/&gt;
    &lt;RadioButton
        android:id="@+id/RadioButton2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="生产测试"/&gt;
&lt;/RadioGroup&gt;
</pre>

</li>
<li>源码中获取：



<pre class="example">mRadioGroup = (RadioGroup) findViewById(R.id.shoes_sel);  
mRadio1 = (RadioButton) findViewById(R.id.RadioButton1);  
mRadio2 = (RadioButton) findViewById(R.id.RadioButton2); 
</pre>

</li>
<li>监听器：



<pre class="example">mRadioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {  
  public void onCheckedChanged(RadioGroup group, int checkedId){
      if (checkedId == mRadio2.getId()){
          //todo
      }  
      else{  
          //todo
      }  
  }  
});  
</pre>

</li>
</ul>

</div>

</div>

<div id="outline-container-3-2-6" class="outline-4">
<h4 id="sec-3-2-6"><span class="section-number-4">3.2.6</span> 对话框</h4>
<div class="outline-text-4" id="text-3-2-6">

<p>比如可以在某个按键后触发一个对话框出来要求用户输入数据，然后点确定等操作。
Java代码如下
</p>


<pre class="example">final AlertDialog dialog = new AlertDialog.Builder(this).create();//对话框对象
//向系统请求一个inflater
LayoutInflater inflater = (LayoutInflater) this.getSystemService(MainActivity.this.LAYOUT_INFLATER_SERVICE);
//该对话框的布局layout
LinearLayout layout = (LinearLayout)inflater.inflate(R.layout.dialog, null);
dialog.setView(layout);
dialog.getWindow().setWindowAnimations(R.style.DialogAnimationStyle);
dialog.show();

//获取对话框中的控件元素，和普通的界面操作一样
final EditText et = (EditText) dialog.getWindow().findViewById(R.id.et_value);
Button close_bt = (Button)dialog.getWindow().findViewById(R.id.close_bt);
close_bt.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
        dialog.dismiss();
    }
});
Button sure_bt = (Button) dialog.getWindow().findViewById(R.id.sure_bt);
sure_bt.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
        String string =et.getText().toString();
        if(string == null)
            dialog.dismiss();
        Calibrate = currentPressure - Float.parseFloat(string);
        dialog.dismiss();
    }
});
</pre>

<p>
相关的界面布局xml文件
</p>


<pre class="example">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="300dip"
    android:layout_height="wrap_content"
    android:background="#ffffff"
    android:orientation="vertical" &gt;
    &lt;TextView
        android:id="@+id/textView1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="10dip"
        android:layout_marginLeft="10dip"
        android:textSize="20dip"
        android:text="校正" /&gt;
    &lt;View 
        android:layout_width="match_parent"
          android:layout_height="1dip"
          android:layout_marginTop="10dip"
          android:background="#009acd" /&gt;
    &lt;LinearLayout 
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="20dip" &gt;
        &lt;TextView
            android:layout_width="100dip"
            android:layout_height="wrap_content"
            android:textSize="15dip"
            android:gravity="center_horizontal"
            android:text="当前值" /&gt;
        &lt;TextView
            android:id="@+id/textView3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="TextView" /&gt;
    &lt;/LinearLayout&gt;
        &lt;LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" 
            android:layout_marginTop="20dip"&gt;
            &lt;TextView
                android:id="@+id/textView2"
                android:layout_width="100dip"
                android:layout_height="wrap_content"
                android:gravity="center_horizontal"
                android:textSize="15dip"
                android:text="校正值" /&gt;
            &lt;EditText
                android:id="@+id/et_value"
                android:layout_width="200dip"
                android:layout_height="wrap_content"
                android:background="#fff0f5"
                android:numeric="integer"
                android:text="" /&gt;
        &lt;/LinearLayout&gt;
            &lt;View 
            android:layout_width="wrap_content"
            android:layout_height="1dip"
            android:layout_marginTop="20dip"
            android:background="@color/darkgray"&gt;
    &lt;LinearLayout
        android:layout_width="match_parent"
        android:layout_height="45dp" &gt;
        &lt;Button
            android:id="@+id/close_bt"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="@drawable/bt_style"
            android:layout_weight="1"
            android:text="取消" /&gt;
        &lt;View 
            android:layout_width="1dip"
            android:layout_height="wrap_content"
            android:background="@color/darkgray"/&gt;
        &lt;Button
            android:id="@+id/sure_bt"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:background="@drawable/bt_style"
            android:layout_weight="1"
            android:text="确定" /&gt;
    &lt;/LinearLayout&gt;
&lt;/LinearLayout&gt;
</pre>

</div>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> service</h3>
<div class="outline-text-3" id="text-3-3">

<ul>
<li>在service中启动activity：



<pre class="example">Intent intent = new Intent(getBaseContext(), MtkPlatformTest.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);必须加这句
startActivity(intent);
</pre>

</li>
</ul>


</div>

<div id="outline-container-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> Bound Service</h4>
<div class="outline-text-4" id="text-3-3-1">

<p>要做绑定服务操作，client需要调用bindService() , 调用后，系统将调用server的onBind()方法，这个方法将返回一个IBinder，这个
IBinder正是反给client，client使用此IBinder来调用server实现的各种服务接口，client要取得这个IBinder，需要实现一个接口
ServiceConnection 作为bindService的参数，此ServiceConnection中的方法onServiceConnected将被系统回调(在onBind执行完后)，而
onBind返回的IBinder正是作为参数传给onServiceConnected，这样client就可以在onServiceConnected里面获得该IBinder；
</p></div>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> broadcast</h3>
<div class="outline-text-3" id="text-3-4">

<p>广播机制可以事务处理异步化，可以将事务的处理放在别的地方，然后在另一个地方
发送一个Intent，系统会根据此Intent来找到相应的广播处理方法来处理，步骤如下。 
</p><ul>
<li>设定IntentFilter，可以在manifest文件中设置，也可以在源码中动态设置，实例
  如下; 



<pre class="example">private static IntentFilter makeIntentFilter() {
    final IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction(ACTION_GATT_CONNECTED);
    intentFilter.addAction(ACTION_GATT_DISCONNECTED);
    intentFilter.addAction(ACTION_GATT_SERVICES_DISCOVERED);
    intentFilter.addAction(ACTION_DATA_AVAILABLE);
    return intentFilter;
}
</pre>

</li>
<li>设置广播事务处理，实例如下;



<pre class="example">private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        final String action = intent.getAction();
        if (ACTION_GATT_CONNECTED.equals(action)) {
            //...
        } else if (ACTION_GATT_DISCONNECTED.equals(action)) {
            //...
        } else if (ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
            //...
        } else if (ACTION_DATA_AVAILABLE.equals(action)) {
            //...
        }
    }
};
</pre>

</li>
<li>注册，将action和事务处理相结合，实例如下;



<pre class="example">registerReceiver(mReceiver, makeIntentFilter());
</pre>

</li>
<li>产生事件源，在别的地方发送消息，实例如下;



<pre class="example">private void broadcastUpdate(final String action) {
    final Intent intent = new Intent(action);
    sendBroadcast(intent);
}
</pre>

</li>
</ul>

</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> 消息机制</h3>
<div class="outline-text-3" id="text-3-5">

<p>Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队例，应
用程序的主线程不断地从这个消息队例中获取消息(Looper)，然后对这些消息进行处
理(Handler)，这样就实现了通过消息来驱动应用程序的执行. 
</p><ul>
<li>Message：消息，其中包含了消息ID，消息处理对象以及处理的数据等，由
  MessageQueue统一列队，终由Handler处理。 
</li>
<li>Handler：处理者，负责Message的发送及处理。使用Handler时，需要实现
  handleMessage(Message msg)方法来对特定的Message进行处理，例如更新UI等。 
</li>
<li>MessageQueue：消息队列，用来存放Handler发送过来的消息，并按照FIFO规则执行。
  当然，存放Message并非实际意义的保存，而是将Message以链表的方式串联起来的，
  等待Looper的抽取。 
</li>
<li>Looper：消息泵，不断地从MessageQueue中抽取Message执行。因此，一个
  MessageQueue需要一个Looper。 
</li>
<li>Thread：线程，负责调度整个消息循环，即消息循环的执行场所。
</li>
</ul>


</div>

<div id="outline-container-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> Handler</h4>
<div class="outline-text-4" id="text-3-5-1">

<p>功能主要是跟UI线程交互用，主要有：
</p><ol>
<li>用handler发送一个message，然后在handler的线程中来接收、处理该消息，以避免直接在UI主线程中处理事务导致影响UI主线程的其
   他处理工作 ；
</li>
<li>你可以将handler对象传给其他进程，以便在其他进程中通过handler给你发送事件；
</li>
<li>通过handler的延时发送message，可以延时处理一些事务的处理；
</li>
<li>线程处理功能：可以使用Handler的post方法，将要处理的事务放在一个thread里面，然后将该线程post到Handler的线程队列中(其实
  这个线程和activity主线程是同一个线程，只是运行了线程的run方法)，则该事务将会在thread里面执行，如果使用
  postDelayed(thread, time)方法，还能设置一个延时time后执行该事务，类似于timer功能；
  实例如下所示。



<pre class="example">//使用handler时首先要创建一个handler
Handler handler = new Handler();
//要用handler来处理多线程可以使用runnable接口，这里先定义该接口
//线程中运行该接口的run函数
Runnable update_thread = new Runnable(){
    public void run(){
        //线程每次执行时输出"UpdateThread..."文字,且自动换行
        //textview的append功能和Qt中的append类似，不会覆盖前面
        //的内容，只是Qt中的append默认是自动换行模式
        text_view.append("\nUpdateThread...");
        //延时1s后又将线程加入到线程队列中
        handler.postDelayed(update_thread, 1000);
    }
};
//将线程接口立刻送到线程队列中
handler.post(update_thread);
//将接口从线程队列中移除
handler.removeCallbacks(update_thread);
</pre>

</li>
<li>异步消息处理功能：同样也是使用上面线程处理功能，将某个线程thread，post到handler的线程队列中，线程队列中处理事务，并可
  以使用handler的sendMessage()，方法向handler中发送message，然后在handler中可以使用handleMessage来处理这个消息；实例如下：



<pre class="example">//创建一个handler，内部完成处理消息方法
Handler update_progress_bar = new Handler(){
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        //显示进度条
        progress_bar.setProgress(msg.arg1);
        //重新把进程加入到进程队列中
        update_progress_bar.post(update_thread);
    }
};
update_progress_bar.post(update_thread);//post线程
Runnable update_thread = new Runnable() {
    int i = 0;
    public void run() {
        i += 10;
        //首先获得一个消息结构
        Message msg = update_progress_bar.obtainMessage();
        //给消息结构的arg1参数赋值
        msg.arg1 = i;
        //延时1s
        Thread.sleep(1000);
        //把消息发送到消息队列中
        update_progress_bar.sendMessage(msg);
        if(i == 100)
            update_progress_bar.removeCallbacks(update_thread);//移除
    }
};
</pre>

</li>
</ol>


</div>

</div>

<div id="outline-container-3-5-2" class="outline-4">
<h4 id="sec-3-5-2"><span class="section-number-4">3.5.2</span> Looper</h4>
<div class="outline-text-4" id="text-3-5-2">


</div>

</div>

<div id="outline-container-3-5-3" class="outline-4">
<h4 id="sec-3-5-3"><span class="section-number-4">3.5.3</span> Message</h4>
<div class="outline-text-4" id="text-3-5-3">

</div>

</div>

<div id="outline-container-3-5-4" class="outline-4">
<h4 id="sec-3-5-4"><span class="section-number-4">3.5.4</span> SharedPreferences</h4>
<div class="outline-text-4" id="text-3-5-4">

<p>很多软件会有配置文件，里面存放这程序运行当中的各个属性值，由于其配置信息并不多，如果采用数据库来存放并不划算，因为数据库
连接跟操作等耗时大大影响了程序的效率，因此我们使用键值这种一一对应的关系来存放这些配置信息。SharedPreferences正是Android
中用于实现这中存储方式的技术。  
SharedPreferences的使用非常简单，能够轻松的存放数据和读取数据。SharedPreferences只能保存简单类型的数据，例如，String、
int等。一般会将复杂类型的数据转换成Base64编码，然后将转换后的数据以字符串的形式保存在 XML文件中，再用SharedPreferences保
存。使用SharedPreferences保存key-value对的步骤如下。
</p><ol>
<li>使用Activity类的getSharedPreferences方法获得SharedPreferences对象，其中存储key-value的文件的名称由
   getSharedPreferences方法的第一个参数指定。
</li>
<li>使用SharedPreferences接口的edit获得SharedPreferences.Editor对象。
</li>
<li>通过SharedPreferences.Editor接口的putXxx方法保存key-value对。其中Xxx表示不同的数据类型。例如：字符串类型的value需要用
   putString方法。
</li>
<li>通过SharedPreferences.Editor接口的commit方法保存key-value对。commit方法相当于数据库事务中的提交（commit）操作。
</li>
</ol>

<p>具体代码的书写流程为。
</p><ul>
<li>存放数据信息
<ol>
<li>打开Preferences，名称为setting，如果存在则打开它，否则创建新的Preferences SharedPreferences settings =
     getSharedPreferences(“setting”, 0);
</li>
<li>让setting处于编辑状态SharedPreferences.Editor editor = settings.edit();
</li>
<li>存放数据editor.putString(“name”,”ATAAW”);editor.putString(“URL”,”ATAAW.COM”);
</li>
<li>完成提交editor.commit();
</li>
</ol>

</li>
<li>读取数据信息
<ol>
<li>获取Preferences: SharedPreferences settings = getSharedPreferences(“setting”, 0);
</li>
<li>取出数据String name = settings.getString(“name”,”默认值”);
     String url = setting.getString(“URL”,”default”);
</li>
</ol>

</li>
</ul>

<p>其中创建的Preferences文件存放位置可以在Eclipse中查看：DDMS-&gt;File Explorer /&lt;package name&gt;/shared<sub>prefs</sub>/setting.xml 
</p></div>
</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 通知栏操作</h3>
<div class="outline-text-3" id="text-3-6">

<p>在Android系统中，发一个状态栏通知还是很方便的。首先，发送一个状态栏通知必须
用到两个类：NotificationManager、Notification。 
</p><ul>
<li>NotificationManager ：  是状态栏通知的管理类，负责发通知、清楚通知等。
  NotificationManager是一个系统Service，必须通过getSystemService()来获取。 



<pre class="example">NotificationManager nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
</pre>

</li>
<li>Notification：是具体的状态栏通知对象，可以设置icon、文字、提示声音、振动
  等等参数。下面是设置一个通知需要的基本参数. 
<ol>
<li>An icon  (通知的图标);
</li>
<li>A title and expanded message  (通知的标题和内容); 
</li>
<li>A PendingIntent   (点击通知执行页面跳转); 
</li>
</ol>

<p>  可选的设置.
</p><ol>
<li>A ticker-text message (状态栏顶部提示消息);
</li>
<li>An alert sound    (提示音)
</li>
<li>A vibrate setting  (振动)
</li>
<li>A flashing LED setting  (灯光)
</li>
</ol>

</li>
</ul>

<p>使用步骤
</p><ol>
<li>创建Notification：通过NotificationManager的notify(int, Notification)方法
   来启动Notification。第一个参数唯一的标识该Notification，第二个参数就是
   Notification对象。 
</li>
<li>更新Notification：调用Notification的setLatestEventInfo方法来更新内容，然
   后调用NotificationManager的notify()方法即可。 
</li>
<li>删除Notification：通过NotificationManager的cancel(int)方法，来清除某个通
   知。其中参数就是Notification的唯一标识ID。当然也可以通过  cancelAll() 来
   清除状态栏所有的通知。 
</li>
<li>Notification设置(振动、铃声等)；
</li>
</ol>




<pre class="example">//新建状态栏通知
baseNF = new Notification();

//设置通知在状态栏显示的图标
baseNF.icon = R.drawable.icon;

//通知时在状态栏显示的内容
baseNF.tickerText = "You clicked BaseNF!";

//通知的默认参数 DEFAULT_SOUND, DEFAULT_VIBRATE, DEFAULT_LIGHTS. 
//如果要全部采用默认值, 用 DEFAULT_ALL.
//此处采用默认声音
baseNF.defaults = Notification.DEFAULT_SOUND;

//第二个参数 ：下拉状态栏时显示的消息标题 expanded message title
//第三个参数：下拉状态栏时显示的消息内容 expanded message text
//第四个参数：点击该通知时执行页面跳转
baseNF.setLatestEventInfo(Lesson_10.this, "Title01", "Content01", pd);

//发出状态栏通知
//The first parameter is the unique ID for the Notification 
// and the second is the Notification object.
nm.notify(Notification_ID_BASE, baseNF);
</pre>

</div>

</div>

<div id="outline-container-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> 程序首选项</h3>
<div class="outline-text-3" id="text-3-7">

<p>一般程序可以通过“设置”也就是首选项做一些更个性化的设置。打开我们的系统设
置中，会看到整个页面被分为几组：无线网络、设备、个人、账户和系统。这个分组
（或者叫分类）就是PreferenceCategory。Wifi右边有开关，这一项就是
CheckBoxPreference；其他还有ListPreference和EditTextPreference。每一次设置，
都会被Preference存下来，这就是setting的数据持久化。我们可以通过
SharedPreference对象获得这个程序的全体设置，Preference的对象获得其中某个设
置。Preference Activity框架由4个部分组成。 
</p><ul>
<li>PreferenceScreen: 是个xml文件，定义了在Preference Screen中显示的层次结构。
  它指定了要显示的文本及控件、值等； 
</li>
<li>PreferenceActivity和PreferenceFragment：首先要说的是，PreferenceActivity
  从API level1中就加入了，那么后续自Android3.0后有了Fragment的概念，同时也
  带来了PreferenceFragment，他们都用于包含PreferenceScreen，在Android3.0前，
  PreferenceActivity直接包含PreferenceScreen，之后，PreferenceScreen包含在
  PreferenceFragment中，而PreferenceFragment又包含到PreferenceActivity； 
</li>
<li>PreferenceHeader：是一个xml文件，3.0后随Fragment引入，用于显示
  PreferenceFragment的层次结构。 
</li>
<li>SharedPreference监听程序：也就是接口onSharedPreferenceChangeListener，用
  于监听界面上的设置变化，这个接口用于监听SharePreference，即只要有设置项改
  变，这个就会被触发回调，区别于OnPreferenceChangeListener是用于监听某项的
  改变，而OnPreferenceClickListener是监听某项的点击 ； 
</li>
</ul>

</div>

</div>

<div id="outline-container-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> menu</h3>
<div class="outline-text-3" id="text-3-8">

<p>menu标签中item标签的主要属性见表<a href="#tbl-menu-bar">tbl-menu-bar</a>
</p><table  border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" id="tbl-menu-bar">
<caption>android menu bar xml属性说明</caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">属性名</th><th scope="col" class="left">说明</th></tr>
</thead>
<tbody>
<tr><td class="left">android:orderInCategory</td><td class="left">指每个item优先级，值越大越低，地方不够就会放到overflow中。</td></tr>
<tr><td class="left">android:title</td><td class="left">item的标题。</td></tr>
<tr><td class="left">android:icon</td><td class="left">item显示的图标。</td></tr>
<tr><td class="left">app:showAsAction</td><td class="left">item显示的方式。</td></tr>
</tbody>
</table>

</div>

</div>

<div id="outline-container-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> gps</h3>
<div class="outline-text-3" id="text-3-9">


</div>

<div id="outline-container-3-9-1" class="outline-4">
<h4 id="sec-3-9-1"><span class="section-number-4">3.9.1</span> 组件</h4>
<div class="outline-text-4" id="text-3-9-1">

<ul>
<li>LocationManagerService：简称LMS，统一管理android平台中能够提供位置服务的
  相关模块； 
</li>
<li>LocationManager：简称LM，为需要使用位置服务的应用程序服务，LMS和LM通过
  binder进行交互； 
</li>
<li>LocationProvider：简称LP，表示android平台中能够提供位置服务的相关模块的统
  称，在所有位置提供者中，android framework实现了其中的PassiveProvider和
  GpsLocationProvider，这两个LP由LMS创建并允许在系统进程中； 
</li>
<li>LocationProviderInterface：LP必须实现这个接口，这些接口对应的对象实例由
  LMS来创建和管理； 
</li>
<li>NetworkLocationProvider：由网络提供的位置服务，android原生代码中不提供相
  关功能，一般第三方厂商会提供； 
</li>
<li>GMS：GoogleMobileService，由Google提供的NetworkLocationProvider，国内的一
  般由百度提供； 
</li>
<li>ILocationProviderProxy：由于一些LP是由第三方提供，他们运行在应用程序所在
  的进程中，所以系统定了这个接口使LMS管理这些由应用程序提供的位置服务； 
</li>
<li>LocationProviderBase：第三方提供LP，必须实现这个抽象类；
</li>
<li>FusedLocationProvider：它自身不提供位置信息，而是综合GpsLP和NetworkLP的位
  置信息，然后向使用者提供最符合使用者需求的数据，平衡电量和数据精度要求； 
</li>
<li>GeocodeProxy：由于需要将位置信息和地址相互转换，而有些位置信息由第三方提
  供，所以LMS利用这个和第三方应用中实现GeocodeProxy的对象进行交互。 
</li>
</ul>

</div>

</div>

<div id="outline-container-3-9-2" class="outline-4">
<h4 id="sec-3-9-2"><span class="section-number-4">3.9.2</span> 操作</h4>
<div class="outline-text-4" id="text-3-9-2">

<ol>
<li>先创建一个LocationManager对象，用于和LMS交互；
</li>
<li>然后调用LocationManager的requestLocationUpdates以设置一个回调接口对象
   LocationListener，同时指出要使用哪个LP，或指定定位精度，由系统决定选择LP；  
</li>
<li>当LP更新相关信息后，LocationListener对应的函数将被调用，应用程序可以在这
   些回调函数中做相应处理； 
</li>
<li>如果应用程序需要在位置和地址信息做转换，则使用Geocoder类提供的函数；
</li>
</ol>


</div>

<div id="outline-container-3-9-2-1" class="outline-5">
<h5 id="sec-3-9-2-1"><span class="section-number-5">3.9.2.1</span> LocationManager</h5>
<div class="outline-text-5" id="text-3-9-2-1">

<p>LocationMangager，位置管理器。要想操作定位相关设备，必须先定义个
LocationManager。我们可以通过如下代码创建LocationManger对象。 
</p>


<pre class="example">LocationManger locationManager=(LocationManager)this.getSystemService(Context.LOCATION_SERVICE); 
</pre>

</div>

</div>

<div id="outline-container-3-9-2-2" class="outline-5">
<h5 id="sec-3-9-2-2"><span class="section-number-5">3.9.2.2</span> LocationListener</h5>
<div class="outline-text-5" id="text-3-9-2-2">

<p>LocationListener，位置监听，监听位置变化，监听设备开关与状态。
</p>


<pre class="example">private LocationListener locationListener=new LocationListener() {
        /**
         * 位置信息变化时触发
         */
        public void onLocationChanged(Location location) {
            updateView(location);
            Log.i(TAG, "时间："+location.getTime()); 
            Log.i(TAG, "经度："+location.getLongitude()); 
            Log.i(TAG, "纬度："+location.getLatitude()); 
            Log.i(TAG, "海拔："+location.getAltitude()); 
        }

        /**
         * GPS状态变化时触发
         */
        public void onStatusChanged(String provider, int status, Bundle extras) {
            switch (status) {
            //GPS状态为可见时
            case LocationProvider.AVAILABLE:
                Log.i(TAG, "当前GPS状态为可见状态");
                break;
            //GPS状态为服务区外时
            case LocationProvider.OUT_OF_SERVICE:
                Log.i(TAG, "当前GPS状态为服务区外状态");
                break;
            //GPS状态为暂停服务时
            case LocationProvider.TEMPORARILY_UNAVAILABLE:
                Log.i(TAG, "当前GPS状态为暂停服务状态");
                break;
            }
        }
        /**
         * GPS开启时触发
         */
        public void onProviderEnabled(String provider) {
            Location location=lm.getLastKnownLocation(provider);
            updateView(location);
        }
        /**
         * GPS禁用时触发
         */
        public void onProviderDisabled(String provider) {
            updateView(null);
        }
    };
</pre>

</div>

</div>

<div id="outline-container-3-9-2-3" class="outline-5">
<h5 id="sec-3-9-2-3"><span class="section-number-5">3.9.2.3</span> Location</h5>
<div class="outline-text-5" id="text-3-9-2-3">

<p>Location，位置信息，通过Location可以获取时间、经纬度、海拔等位置信息。上面
采用locationListener里面的onLocationChanged()来获取location，下面讲述如何主
动获取location。 
</p>


<pre class="example">Location location=locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
system.out.println("时间："+location.getTime());
system.out.println("经度："+location.getLongitude());  
</pre>

</div>

</div>

<div id="outline-container-3-9-2-4" class="outline-5">
<h5 id="sec-3-9-2-4"><span class="section-number-5">3.9.2.4</span> GpsStatus.Listener</h5>
<div class="outline-text-5" id="text-3-9-2-4">

<p>GpsStatus.Listener，GPS状态监听，包括GPS启动、停止、第一次定位、卫星变化等
事件。  
</p>


<pre class="example">//状态监听
    GpsStatus.Listener listener = new GpsStatus.Listener() {
        public void onGpsStatusChanged(int event) {
            switch (event) {
            //第一次定位
            case GpsStatus.GPS_EVENT_FIRST_FIX:
                Log.i(TAG, "第一次定位");
                break;
            //卫星状态改变
            case GpsStatus.GPS_EVENT_SATELLITE_STATUS:
                Log.i(TAG, "卫星状态改变");
                //获取当前状态
                GpsStatus gpsStatus=lm.getGpsStatus(null);
                //获取卫星颗数的默认最大值
                int maxSatellites = gpsStatus.getMaxSatellites();
                //创建一个迭代器保存所有卫星 
                Iterator&lt;GpsSatellite&gt; iters = gpsStatus.getSatellites().iterator();
                int count = 0;     
                while (iters.hasNext() &amp;&amp; count &lt;= maxSatellites) {     
                    GpsSatellite s = iters.next();     
                    count++;     
                }   
                System.out.println("搜索到："+count+"颗卫星");
                break;
            //定位启动
            case GpsStatus.GPS_EVENT_STARTED:
                Log.i(TAG, "定位启动");
                break;
            //定位结束
            case GpsStatus.GPS_EVENT_STOPPED:
                Log.i(TAG, "定位结束");
                break;
            }
        };
    };
//绑定监听状态
lm.addGpsStatusListener(listener);
</pre>

</div>

</div>

<div id="outline-container-3-9-2-5" class="outline-5">
<h5 id="sec-3-9-2-5"><span class="section-number-5">3.9.2.5</span> GpsStatus</h5>
<div class="outline-text-5" id="text-3-9-2-5">

<p>GpsStatus，GPS状态信息，上面在卫星状态变化时，我们就用到了GpsStatus。 
</p>


<pre class="example">//实例化    
GpsStatus gpsStatus = locationManager.getGpsStatus(null); // 获取当前状态    
//获取默认最大卫星数    
int maxSatellites = gpsStatus.getMaxSatellites();     
//获取第一次定位时间（启动到第一次定位）    
int costTime=gpsStatus.getTimeToFirstFix();   
//获取卫星    
Iterable&lt;GpsSatellite&gt; iterable=gpsStatus.getSatellites();   
//一般再次转换成Iterator    
Iterator&lt;GpsSatellite&gt; itrator=iterable.iterator();
</pre>

</div>

</div>

<div id="outline-container-3-9-2-6" class="outline-5">
<h5 id="sec-3-9-2-6"><span class="section-number-5">3.9.2.6</span> GpsSatellite</h5>
<div class="outline-text-5" id="text-3-9-2-6">

<p>GpsSatellite，定位卫星，包含卫星的方位、高度、伪随机噪声码、信噪比等信息 
</p>


<pre class="example">//获取卫星    
Iterable&lt;GpsSatellite&gt; iterable=gpsStatus.getSatellites();   
//再次转换成Iterator    
Iterator&lt;GpsSatellite&gt; itrator=iterable.iterator();   
//通过遍历重新整理为ArrayList    
ArrayList&lt;GpsSatellite&gt; satelliteList=new ArrayList&lt;GpsSatellite&gt;();    
int count=0;   
int maxSatellites=gpsStatus.getMaxSatellites();   
while (itrator.hasNext() &amp;&amp; count &lt;= maxSatellites) {     
    GpsSatellite satellite = itrator.next();     
    satelliteList.add(satellite);     
    count++;   
}    
System.out.println("总共搜索到"+count+"颗卫星");   
//输出卫星信息    
for(int i=0;i&lt;satelliteList.size();i++){   
    //卫星的方位角，浮点型数据    
    System.out.println(satelliteList.get(i).getAzimuth());   
    //卫星的高度，浮点型数据    
    System.out.println(satelliteList.get(i).getElevation());   
    //卫星的伪随机噪声码，整形数据    
    System.out.println(satelliteList.get(i).getPrn());   
    //卫星的信噪比，浮点型数据    
    System.out.println(satelliteList.get(i).getSnr());   
    //卫星是否有年历表，布尔型数据    
    System.out.println(satelliteList.get(i).hasAlmanac());   
    //卫星是否有星历表，布尔型数据    
    System.out.println(satelliteList.get(i).hasEphemeris());   
    //卫星是否被用于近期的GPS修正计算    
    System.out.println(satelliteList.get(i).hasAlmanac());   
}
</pre>

</div>
</div>

</div>

<div id="outline-container-3-9-3" class="outline-4">
<h4 id="sec-3-9-3"><span class="section-number-4">3.9.3</span> 位置模拟</h4>
<div class="outline-text-4" id="text-3-9-3">

<p>大体思路如下。
</p><ol>
<li>获取待模拟的位置；
</li>
<li>将位置信息植入需要的Provider里面, 下面示例代码以模拟位置植入GPS<sub>PROVIDER</sub>
   中为例； 



<pre class="example">//xml权限 
&lt;uses-permission android:name="android.permission.ACCESS_MOCK_LOCATION"&gt;
public static void setLocation(Context context, LatLonBean bean) {  
     LocationManager locmanag = (LocationManager) context  
             .getSystemService(Context.LOCATION_SERVICE);  
     //关键代码
     String mock = LocationManager.GPS_PROVIDER;  
     locmanag.addTestProvider(mock, false, true, false, false, false, false,  
             false, 0, 5);  
     locmanag.setTestProviderEnabled(mock, true);  
     //构造位置信息
     Location loc = new Location(mock);  
     loc.setTime(System.currentTimeMillis());  
     loc.setLatitude(Double.parseDouble(bean.getLat()));  
     loc.setLongitude(Double.parseDouble(bean.getLon()));  
     loc.setAccuracy(Criteria.ACCURACY_FINE);// 精确度  
     loc.setElapsedRealtimeNanos(SystemClock.elapsedRealtimeNanos());// 实时运行时间  
     locmanag.setTestProviderStatus(mock, LocationProvider.AVAILABLE, null,  
             System.currentTimeMillis());  
     //位置信息植入
     locmanag.setTestProviderLocation(mock, loc);  
 }  
</pre>

</li>
<li>在android手机设置请确保您已在“允许模拟位置”复选框打勾 ；
</li>
<li>像普通使用gps定位一样的使用onLocationChanged()会被系统回调。
</li>
</ol>

</div>
</div>

</div>

<div id="outline-container-3-10" class="outline-3">
<h3 id="sec-3-10"><span class="section-number-3">3.10</span> bt</h3>
<div class="outline-text-3" id="text-3-10">


</div>

<div id="outline-container-3-10-1" class="outline-4">
<h4 id="sec-3-10-1"><span class="section-number-4">3.10.1</span> 概念</h4>
<div class="outline-text-4" id="text-3-10-1">

<ul>
<li>BluetoothAdapter：代表手机本地的蓝牙模块，BluetoothAdapter是所有蓝牙互操
  作的入口。使用它，你可以discover其他的蓝牙设备，轮询已经bonded(paired)的
  设备列表，使用MAC地址实例化一个远端Bluetoothdevice，生成一个
  BluetoothServerSocket来监听其他设备。 
</li>
<li>BluetoothDevice：代表一个远端的蓝牙设备，本地蓝牙模块使用BluetoothDevice
  通过一个BluetoothSocket来请求一个远端设备连接或者请求远端设备的设备名，地
  址，绑定状态等； 
</li>
<li>BluetoothSocket：代表一个接口，通过这个接口应用程序可以利用InputStream和
  OutputStream来和其他蓝牙设备交换数据； 
</li>
<li>BluetoothServerSocket：代表一个server socket，它用于监听收到的请求。为了
  连接两个android设备，某个设备必须开启一个server socket，当一个远端蓝牙设
  备发起一个连接请求到这个设备时，这个设备如果接受这个请求，它的
  BluetoothServerSocket会返回一个BluetoothSocket给它； 
</li>
<li>BluetoothClass：用于描述蓝牙设备的一般属性和能力。它是只读的属性集，定义
  了设备的主次设备类和它的服务，然而这个BluetoothClass并不是这个蓝牙设备支
  持的所有蓝牙profile和services的描述； 
</li>
<li>BluetoothProfile：是一个蓝牙profile的接口；
</li>
<li>BluetoothHeadset：提供对手机上蓝牙耳机的支持，它包含蓝牙耳机和免提的
  profile； 
</li>
<li>BluetoothA2dp：定义了通过蓝牙连接的设备间传输音频流的质量，A2DP表示
  Advanced Audio Distribution Profile； 
</li>
<li>BluetoothHealth：代表了Health Device Profile；
</li>
<li>BluetoothHealthCallback：它是一个BluetoothHealth回调的抽象类。这个回调处
  理接收到的应用程序注册状态以及蓝牙通道状态的更新； 
</li>
<li>BluetoothHealthAppConfiguration：代表应用程序关于BluetoothHealth的配置； 
</li>
<li>BluetoothProfile.ServiceListener：它是一个通知BluetoothProfile IPC客户端
  的接口，通知对service连接的状态； 
</li>
</ul>

</div>

</div>

<div id="outline-container-3-10-2" class="outline-4">
<h4 id="sec-3-10-2"><span class="section-number-4">3.10.2</span> 蓝牙权限</h4>
<div class="outline-text-4" id="text-3-10-2">

<p>应用程序要用蓝牙功能，必须要声明蓝牙权限“BLUETOOTH”。代码如下
</p>


<pre class="example">&lt;manifest ... &gt;
  &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;
  ...
&lt;/manifest&gt;
</pre>

<p>
如果应用程序还需要“初始化设备发现”，操作“蓝牙设置”，那还需要声明
“BLUETOOTH_ADMIN”的权限，另外这个权限可以赋予一些功能，比如发现本地蓝牙
设备，修改蓝牙设置；如有要使用“BLUETOOTH_ADMIN”的声明，还必须要有上面的
“BLUETOOTH”权限。 
</p></div>

</div>

<div id="outline-container-3-10-3" class="outline-4">
<h4 id="sec-3-10-3"><span class="section-number-4">3.10.3</span> 设置蓝牙</h4>
<div class="outline-text-4" id="text-3-10-3">

<p>如果要使用蓝牙，需检查手机是否支持蓝牙，并且要保证已经使能。这需要两步操作。 
</p><ol>
<li>获取BluetoothAdapter:BluetoothAdapter是所有蓝牙活动所必须要求的。要获得
   BluetoothAdapter可以调用getDefaultAdapter()方法，它将返回一个
   BluetoothAdapter，如果返回null，代表设备不支持蓝牙，代码如下。 



<pre class="example">BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
if (mBluetoothAdapter == null) {
     // Device does not support Bluetooth
}
</pre>

</li>
<li>使能蓝牙:使用蓝牙前要确定蓝牙是否已经使能，使用isEnable()方法，如果返回
   false，表示蓝牙是禁能的。要请求蓝牙开启，可以使用
   startActivityForResult()带上ACTION_REQUEST_ENABLE的intent，这样将会触
   发一个系统设置的请求来使能蓝牙，代码如下, 将会出现一个对话框请求用户使能
   蓝牙，用户可以允许也可以不允许，ACTION_REQUEST_ENABLE是一个本地定义的
   整数(大于0)，并且会在onActivityResult()回调方法中返回作为requestCode参数，
   如果使能蓝牙成功，Activity会在onActivityResult()收到RESULT_OK结果码，否
   则结果码是RESULT_CANCEL 



<pre class="example">if (!mBluetoothAdapter.isEnabled()) {
 Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
 startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
}
</pre>

<p>
   同样，应用程序还可以监听ACTION_STATE_CHANGED广播intent，这个intent会在
   蓝牙状态变化时被系统广播出来， 这个广播包含指示蓝牙新旧状态的额外域：
   EXTRA_STATE和EXTRA_PREVIOUS_STATE。这2个域的值可能取
   STATE_TURNING_ON, STATE_ON,STATE_OFF，STATE_TURNING_OFF。   
</p></li>
</ol>

</div>

</div>

<div id="outline-container-3-10-4" class="outline-4">
<h4 id="sec-3-10-4"><span class="section-number-4">3.10.4</span> 寻找设备</h4>
<div class="outline-text-4" id="text-3-10-4">

<p>可以使用BluetoothAdapter搜索远端设备，要么通过“搜索设备”，要么通过轮询配
对绑定列表里面的设备。搜索设备通过一个扫描过程搜索周边的蓝牙设备并向他们请
求一些信息(这个过程大概有“discovering”，“inquiring”，“scanning”)。然
而这个被搜索到的设备只有在使能了可发现属性后，才会回应这些请求，回应信息大
概有设备名，类别，唯一的MAC地址。有了这些后，搜索设备的发起方就可以选择一个
设备初始化一个链接操作。一旦和远端设备进行链接，并且是首次链接，一个配对请
求就会自动的呈现给用户。当配对过程完成后，远端设备的基本信息(比如设备名，类
别，MAC)就会被保存下来并能够通过蓝牙API读取，使用一个已知的MAC地址可以在任
何时候发起连接操作而不需要再进行搜索过程。要记住的是已配对和已连接有所不同，
配对意味着两个设备知道互相的存在，拥有一个用于认证的共享的链接密钥
(link-key)，能够建立一个加密的链路。连接意味着设备间当前共享一个RFCOMM通道，
可以互相进行数据传输。当前的android蓝牙API要求设备在建立RFCOMM通道前做配对
操作。(配对是在使用蓝牙API初始化一个加密连接时自动进行)下面的章节描述的是已
经配对设备如何进行寻找设备，或者使用设备搜索过程来搜索设备。 
</p></div>

</div>

<div id="outline-container-3-10-5" class="outline-4">
<h4 id="sec-3-10-5"><span class="section-number-4">3.10.5</span> 轮询已配对的设备</h4>
<div class="outline-text-4" id="text-3-10-5">

<p>在进行搜索设备前，先轮询已配对设备的集合看看是否有我们需要的设备，调用
BluetoothAdapter的getBondedDevices()即可。它将返回一个已配对设备的集合。比
如，可以轮询所有的设备并使用ArrayAdapter将设备名展示给用户。 
</p>


<pre class="example">Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();
// If there are paired devices
if (pairedDevices.size() &gt; 0) {
    // Loop through paired devices
    for (BluetoothDevice device : pairedDevices) {
        // Add the name and address to an array adapter to show in a ListView
        mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
    }
}
</pre>

<p>
为了初始化一个连接，仅需要从BluetoothDevice对象中获得MAC地址。
</p></div>

</div>

<div id="outline-container-3-10-6" class="outline-4">
<h4 id="sec-3-10-6"><span class="section-number-4">3.10.6</span> 搜索设备</h4>
<div class="outline-text-4" id="text-3-10-6">

<p>要发起搜索设备，只需要简单的调用startDiscovery().这个过程是异步的，调用这个
方法会立刻返回一个布尔值指示搜索是否成功启动。搜索过程常常先inquiry scan大
约12秒，再使用page scan去获取每个设备的蓝牙设备名。应用程序注册一个
BroadcastReceiver来接收“ACTION_FOUND”的intent，对于每个搜索到的设备，系
统将会广播这个intent，这个intent会包含额外域EXTRA_DEVICE和EXTRA_CLASS，对
应着“BluetoothDevice”和“BluetoothClass”。代码如下 
</p>


<pre class="example">// Create a BroadcastReceiver for ACTION_FOUND
private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        // When discovery finds a device
        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
            // Get the BluetoothDevice object from the Intent
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            // Add the name and address to an array adapter to show in a ListView
            mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
        }
    }
};
// Register the BroadcastReceiver
IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
registerReceiver(mReceiver, filter); // Don't forget to unregister during onDestroy
</pre>

<p>
警告：做设备搜索是个非常耗费系统资源的操作，一旦发现了目标设备，确保在连接
前使用cancelDiscovery()停止掉搜索过程，并且如果已经保持了一个连接，再搜索操
作势必会减少连接的可用带宽，所以当连接设备时最好不要做搜索操作。 
</p></div>

</div>

<div id="outline-container-3-10-7" class="outline-4">
<h4 id="sec-3-10-7"><span class="section-number-4">3.10.7</span> 使能可发现性</h4>
<div class="outline-text-4" id="text-3-10-7">

<p>如果愿意本地设备被其他设备搜索到，可使用ACTION_REQUEST_DISCOVERABLE的
intent调用startActivityForResult(Intent，int)，它将向系统发起一个请求进行可
发现性设置。默认将保持120秒时间，也可以通过给intent增加
EXTRA_DISCOVERABLE_DURATION的额外域值来改变这个持续时间。这个域值最大可设
3600秒，0代表始终可发现。设置为其他值将自动设成120秒，下面代码设置持续时间
为300秒。 
</p>


<pre class="example">Intent discoverableIntent = new
Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);
startActivity(discoverableIntent);
</pre>

<p>
系统将显示一个对话框来请求设备可发现性的用户权限。如果用户选择YES，设备将保
持这个时间的可发现性，activity也将收到一个回调onActivityResult(), 里面会附
带一个等于持续时间的result code。如果选择了NO，或者发送错误，这个result
code将是RESULT_CANCEL。<br/>
注意：如果设备没有开启蓝牙，而使能了蓝牙可发现性，将会自动的开启蓝牙。<br/>
如果希望在系统的可发现性改变时被通知，可以注册一个BroadcastReceiver来监听
ACTION_SCAN_MODE_CHANGED的intent。这个intent将包含两个额外域，
EXTRA_SCAN_MODE和EXTRA_PREVIOUS_SCAN_MODE，对应着新旧扫描模式。其可能
值有SCAN_MODE_CONNECTABLE_DISCOVERABLE, SCAN_MODE_CONNECTABLE, 或
SCAN_MODE_NONE，指示了设备要么处于可发现模式，不处于可发现模式但是可以接
收连接请求，既不处于可发现模式也不能接收连接请求。如果只是想初始化一个到远
端设备的链接，可以不用开启可发现模式。使能可发现模式仅仅只是在应用程序需要
主导一个可以接收连接的server socket，因为远端设备在初始化一个连接前必须能够
发现这个设备。 
</p></div>

</div>

<div id="outline-container-3-10-8" class="outline-4">
<h4 id="sec-3-10-8"><span class="section-number-4">3.10.8</span> 连接设备</h4>
<div class="outline-text-4" id="text-3-10-8">

<p>为了应用程序在设备间建立连接，必须实现服务端和客户端机制，因为一个设备必须
开启server socket，另一个设备必须初始化这个连接(使用设备的MAC地址)。当服务
端和客户端在共同的RFCOMM通道都有了已连接的BluetoothSocket则可认为两者已连接。
从此后，每个设备获得输入输出流和数据传输就可开始，这部分要点在后面介绍。<br/>
服务端设备和客户端设备获得BluetoothSocket的方式不同。服务端当有一个连接进入
被接受时就获得了，而客户端当开启一个RFCOMM通道给服务端时就获得了。 <br/>
注意：如果两个设备之前没有配对过，android framework将会自动显示一个配对请求
通知或者对话框给用户(就是那个带密码的对话框)。这样当尝试连接设备是，应用程
序不需要关注设备是否配对过。RFCOMM连接尝试将会被阻塞直到用户成功配对，或者
用户拒绝配对，或者配对失败而超时。 
</p></div>

</div>

<div id="outline-container-3-10-9" class="outline-4">
<h4 id="sec-3-10-9"><span class="section-number-4">3.10.9</span> 服务端的连接</h4>
<div class="outline-text-4" id="text-3-10-9">

<p>当要连接两个设备时，其中一个必须作为一个服务端保存一个打开的
BluetoothServerSocket。它的目的是监听进来的链接请求，并且当接受时，提供一个
可连接的BluetoothSocket。当BluetoothSocket已经从BluetoothServerSocket获得后，
BluetoothServerSocket就可以丢弃了，除非还想介入其他连接。 
</p><ol>
<li>通过调用listenUsingRfcommWithServiceRecord(String, UUID)来获得
   BluetoothServerSocket。这个String是服务的标示名，系统会自动将它写入
   SDP(service discovery protocol)的数据库入口(标示名可以随意编写，并且可以
   直接采用应用程序的名字)。UUID也同样被包含在数据库入口并且是同客户端的连
   接协议的基础。当客户端试图连接这个设备，他会携带一个UUID，唯一代表了它想
   连接的服务 。 
</li>
<li>开始调用accept()来监听连接请求。这是一个阻塞调用。他会立刻返回不管连接是
   否被接受。只有当远端设备使用了能够匹配这个注册的在监听的服务端Socket的
   UUID来发出连接请求，连接才回被接受。当连接成功后，accept()会返回一个已连
   接的BluetoothSocket。 
</li>
<li>除非想继续接收连接请求，否则调用close().这会释放服务端Socket和它的资源，
   但是不会关闭被accept()返回的BluetoothSocket。与TCP/IP不同的是，RFCOMM在
   同一时刻每个通道只允许一个连接的客户端，所以在大多数情况在接受了连接请求
   后立刻调用BluetoothServiceSocket的close()。  
</li>
</ol>

<p>accept()调用不应该在主Activity的UI线程上执行，因为它是阻塞调用会阻止程序的
交互操作。常常使用一个新的线程来做所有的BluetoothServerSocket和
BluetoothSocket的工作。要退出accept()这样的阻塞调用，可以从其他的线程调用
BluetoothServerSocket(或BluetoothSocket)的close()，阻塞调用会立刻返回。注意
BluetoothServerSocket和BluetoothSocket所有的方法都是线程安全的。 <br/>
代码实例：这里有一个简单线程调用，用于服务模块接收进来的连接。
</p>


<pre class="example">private class AcceptThread extends Thread {
    private final BluetoothServerSocket mmServerSocket;

    public AcceptThread() {
        // Use a temporary object that is later assigned to mmServerSocket,
        // because mmServerSocket is final
        BluetoothServerSocket tmp = null;
        try {
            // MY_UUID is the app's UUID string, also used by the client code
            tmp = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID);
        } catch (IOException e) { }
        mmServerSocket = tmp;
    }

    public void run() {
        BluetoothSocket socket = null;
        // Keep listening until exception occurs or a socket is returned
        while (true) {
            try {
                socket = mmServerSocket.accept();
            } catch (IOException e) {
                break;
            }
            // If a connection was accepted
            if (socket != null) {
                // Do work to manage the connection (in a separate thread)
                manageConnectedSocket(socket);
                mmServerSocket.close();
                break;
            }
        }
    }

    /** Will cancel the listening socket, and cause the thread to finish */
    public void cancel() {
        try {
            mmServerSocket.close();
        } catch (IOException e) { }
    }
}
</pre>

<p>
在这个例子中，只打算接收一个连接请求，所以一旦连接被接受并且BluetoothSocket被接受，应用程序发送一个已接受的
BluetoothSocket给一个单独的线程，然后关闭BluetoothServerSocket并且跳出循环。
注意当accept()返回BluetoothSocket后，socket就已经连接，所以不应该再调用connect()(像在客户端侧做的那样)。
manageConnectedSocket()在应用中是个虚方法，他会初始化线程来传输数据，如前面介绍说的。
最好一旦监听完连接请求后，就关闭BluetoothServerSocket。在这个例子中，一旦BluetoothSocket()被接受，close()就被调用。当需
要在服务端Socket停止监听时，也可以在线程中提供一个public方法关闭这个private的BluetoothSocket。
</p></div>

</div>

<div id="outline-container-3-10-10" class="outline-4">
<h4 id="sec-3-10-10"><span class="section-number-4">3.10.10</span> 客户端的连接</h4>
<div class="outline-text-4" id="text-3-10-10">

<p>为了初始化一个到远端设备(它保持着一个开放的服务端Socket)的连接，必须首先获
得一个代表远端设备的BluetoothDevice对象(上面有介绍)。然后用这个对象获取一个
BluetoothSocket并初始化连接。基本流程如下。 
</p><ol>
<li>调用createRfcommSocketToServiceRecord(UUID)使用BluetoothDevice获取一个
   BluetoothSocket。这样会初始化一个BluetoothSocket连接到BluetoothDevice。
   这个传入的UUID和服务端设备调用BluetoothServiceSocket的
   listenUsingRfcommWithServiceRecord(String, UUID)使用的UUID匹配。在服务端
   和客户端应用程序中使用这个相同的UUID是一种硬编码。 
</li>
<li>调用connect()初始化连接。一旦调用这个方法，系统将会发起一个SDP搜寻远端设
   备以匹配这个UUID。如果搜寻成功并且远端设备接受了这个连接，就会在连接期间
   共享这个RFCOMM通道，并且connect()返回。这个方法是阻塞调用。不管任何原因，
   如果这个连接失败或者connect()调用超时(大概12秒)，那么它会抛出一个异常。
   因为connect()是个阻塞调用，连接过程应该总是在一个独立于主Activity线程的
   线程中使用。 
</li>
</ol>

<p>注意：应该确保当调用connect()时，设备没有进行搜索操作。如果在继续搜索，那么
连接的尝试将会强烈的减慢并失败。代码实例：下面是初始化蓝牙连接的线程实例。 
</p>


<pre class="example">private class ConnectThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final BluetoothDevice mmDevice;

    public ConnectThread(BluetoothDevice device) {
        // Use a temporary object that is later assigned to mmSocket,
        // because mmSocket is final
        BluetoothSocket tmp = null;
        mmDevice = device;

        // Get a BluetoothSocket to connect with the given BluetoothDevice
        try {
            // MY_UUID is the app's UUID string, also used by the server code
            tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
        } catch (IOException e) { }
        mmSocket = tmp;
    }

    public void run() {
        // Cancel discovery because it will slow down the connection
        mBluetoothAdapter.cancelDiscovery();

        try {
            // Connect the device through the socket. This will block
            // until it succeeds or throws an exception
            mmSocket.connect();
        } catch (IOException connectException) {
            // Unable to connect; close the socket and get out
            try {
                mmSocket.close();
            } catch (IOException closeException) { }
            return;
        }

        // Do work to manage the connection (in a separate thread)
        manageConnectedSocket(mmSocket);
    }

    /** Will cancel an in-progress connection, and close the socket */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}
</pre>

</div>

</div>

<div id="outline-container-3-10-11" class="outline-4">
<h4 id="sec-3-10-11"><span class="section-number-4">3.10.11</span> 管理连接</h4>
<div class="outline-text-4" id="text-3-10-11">

<p>当成功的链接两个设备，每个都会拥有一个已连接的BluetoothSocket。从此将会有趣
了因为可以在设备间分享数据。使用BluetoothSocket，这个传输任意数据的过程将会
很简单。 
</p><ol>
<li>获取InputStream和OutputStream，他们通过Socket处理传输，对应着使用
   getInputStream()和getOutputStream()。 
</li>
<li>使用read(byte[])和write(byte[])读写数据流。
</li>
</ol>

<p>很简单，当然有一些实现细节需要考虑。首先也是最重要的，需要使用一个专门的线
程来对所有的流进行读写。这个很重要，因为read(byte[])和write(byte[])两个方法
都是阻塞调用。read(byte[])调用时会被阻塞，除非从流中读到了一些数据，
write(byte[])常常不会被阻塞，但是当远端设备没有调用read(byte[])迅速的读走数
据，并且交互buffer已经满了，而进行流控时会被阻塞。所以线程中的主循环应该专
门用于读取InputStream。线程中可以有一个单独的public方法来初始化OutputStream
的写入。代码实例。 
</p>


<pre class="example">private class ConnectedThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final InputStream mmInStream;
    private final OutputStream mmOutStream;

    public ConnectedThread(BluetoothSocket socket) {
        mmSocket = socket;
        InputStream tmpIn = null;
        OutputStream tmpOut = null;

        // Get the input and output streams, using temp objects because
        // member streams are final
        try {
            tmpIn = socket.getInputStream();
            tmpOut = socket.getOutputStream();
        } catch (IOException e) { }

        mmInStream = tmpIn;
        mmOutStream = tmpOut;
    }

    public void run() {
        byte[] buffer = new byte[1024];  // buffer store for the stream
        int bytes; // bytes returned from read()

        // Keep listening to the InputStream until an exception occurs
        while (true) {
            try {
                // Read from the InputStream
                bytes = mmInStream.read(buffer);
                // Send the obtained bytes to the UI activity
                mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer)
                        .sendToTarget();
            } catch (IOException e) {
                break;
            }
        }
    }

    /* Call this from the main activity to send data to the remote device */
    public void write(byte[] bytes) {
        try {
            mmOutStream.write(bytes);
        } catch (IOException e) { }
    }

    /* Call this from the main activity to shutdown the connection */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}
</pre>

<p>
构造函数获得一个必要的流，一经执行线程将会等待InputStream接收数据。当read(byte[])从流里返回一些数据时，将会使用父类的一
个成员Handler来将数据发送给主Activity。然后它将返回并且等待更多的数据从流里获得。
对外发送数据就和从主Activity中调用线程的write()方法一样简单，只需要传入需要发送的数据。这个方法会调用write(byte[])来发送
数据给远端设备。
线程的cancel()方法很重要，链接可以在任何时候通过关闭BluetoothSocket来中断。当使用完蓝牙连接时调用它是很有必要的。
</p></div>

</div>

<div id="outline-container-3-10-12" class="outline-4">
<h4 id="sec-3-10-12"><span class="section-number-4">3.10.12</span> 使用Profiles</h4>
<div class="outline-text-4" id="text-3-10-12">

<p>从android3.0开始，蓝牙API包含了对蓝牙Profile的支持。Bluetooth Profile是个无
线接口，以蓝牙为基础沟通不同的设备。免提Profile就是一例。对于手机连接到无线
耳机，两个设备都必须支持免提Profile。可以实现接口BluetoothProfile写入一个你
自己的类别来支持一个特定的蓝牙Profile。android蓝牙API提供下面蓝牙Profile的
实现。 
</p><ol>
<li>Headset：耳机；
</li>
<li>A2DP：Advanced Audio Distribution Profile；
</li>
<li>Health Device：android4.0以上(API level 14)
</li>
</ol>

<p>下面是使用这些Profile的简单步骤。
</p><ol>
<li>获取默认的Adapter(BluetoothAdapter)；
</li>
<li>使用getProfileProxy()来和这个Profile相关的代理Profile建立连接。下面的例
   子展示代理Profile对象是BluetoothHeadset的一个实例。 
</li>
<li>设置BluetoothProfile.ServiceListener。这个Listener当连接或者断开连接到服
   务端时通知BluetoothProfile进程客户端。 
</li>
<li>在onServiceConnected()中获得代理Profile对象的句柄。
</li>
<li>一旦有代理Profile对象，就可以利用它监视连接状态和做关于Profile的其他操作。 
</li>
</ol>

<p>代码实例，下面的代码片段展示了怎样连接到BluetoothHeadset代理对象。
</p>


<pre class="example">BluetoothHeadset mBluetoothHeadset;

// Get the default adapter
BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

// Establish connection to the proxy.
mBluetoothAdapter.getProfileProxy(context, mProfileListener, BluetoothProfile.HEADSET);

private BluetoothProfile.ServiceListener mProfileListener = new BluetoothProfile.ServiceListener() {
    public void onServiceConnected(int profile, BluetoothProfile proxy) {
        if (profile == BluetoothProfile.HEADSET) {
            mBluetoothHeadset = (BluetoothHeadset) proxy;
        }
    }
    public void onServiceDisconnected(int profile) {
        if (profile == BluetoothProfile.HEADSET) {
            mBluetoothHeadset = null;
        }
    }
};
// ... call functions on mBluetoothHeadset
// Close proxy connection after use.
mBluetoothAdapter.closeProfileProxy(mBluetoothHeadset);
</pre>

</div>

</div>

<div id="outline-container-3-10-13" class="outline-4">
<h4 id="sec-3-10-13"><span class="section-number-4">3.10.13</span> 制造商自定义AT指令</h4>
<div class="outline-text-4" id="text-3-10-13">

<p>从android3.0开始，应用程序就能注册接收预定义的由Headset发出的系统通知。 
</p></div>

</div>

<div id="outline-container-3-10-14" class="outline-4">
<h4 id="sec-3-10-14"><span class="section-number-4">3.10.14</span> 健康设备Profile</h4>
<div class="outline-text-4" id="text-3-10-14">

<p>从android4.0开始，引入对健康设备Profile(HDP)的支持。
</p></div>
</div>

</div>

<div id="outline-container-3-11" class="outline-3">
<h3 id="sec-3-11"><span class="section-number-3">3.11</span> ble</h3>
<div class="outline-text-3" id="text-3-11">

</div>

</div>

<div id="outline-container-3-12" class="outline-3">
<h3 id="sec-3-12"><span class="section-number-3">3.12</span> sensor</h3>
<div class="outline-text-3" id="text-3-12">

<p>传感器包括加速度传感器、陀螺仪、气压计等，这些传感器通常用于感知手机当前的
状态。其使用方法都有固定的模式。 
</p>
</div>

<div id="outline-container-3-12-1" class="outline-4">
<h4 id="sec-3-12-1"><span class="section-number-4">3.12.1</span> 传感器类型</h4>
<div class="outline-text-4" id="text-3-12-1">

<p>传感器类型定义在Sensor.java类中。
</p><ol>
<li>加速度传感器：Sensor.TYPE_ACCELEROMETER;
</li>
<li>磁传感器：Sensor.TYPE_MAGNETIC<sub>FIELD</sub>;
</li>
<li>方向传感器：Sensor.TYPE_ORIENTATION;
</li>
<li>陀螺仪传感器：Sensor.TYPE_GYROSCOPE;
</li>
<li>感光传感器：Sensor.TYPE_LIGHT;
</li>
<li>压力传感器：Sensor.TYPE_PRESSURE；
</li>
<li>温度传感器：Sensor.TYPE_TEMPERATURE；
</li>
<li>接近传感器：Sensor.TYPE_PROXIMITY；
</li>
<li>重力传感器：Sensor.TYPE_GRAVITY；
</li>
<li>线性加速度传感器：Sensor.TYPE_LINEAR_ACCELERATION；
</li>
<li>旋转传感器：Sensor.TYPE_ROTATION_VECTOR；
</li>
<li>相对湿度传感器：Sensor.TYPE_RELATIVE_HUMIDITY；
</li>
<li>环境温度传感器：Sensor.TYPE_AMBIENT_TEMPERATURE；
</li>
<li>磁场标定传感器：Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED；
</li>
<li>游戏旋转矢量传感器：Sensor.TYPE_GAME_ROTATION_VECTOR；
</li>
<li>陀螺仪标定传感器：Sensor.TYPE_GYROSCOPE_UNCALIBRATED；
</li>
<li>Sensor.TYPE_SIGNIFICANT_MOTION
</li>
<li>Sensor.TYPE_STEP_DETECTOR
</li>
<li>Sensor.TYPE_STEP_COUNTER
</li>
<li>Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR
</li>
<li>Sensor.TYPE_HEART_RATE_MONITOR
</li>
<li>Sensor.TYPE_WAKE_UP_TILT_DETECTOR
</li>
<li>Sensor.TYPE_WAKE_GESTURE
</li>
<li>Sensor.TYPE_GLANCE_GESTURE
</li>
<li>Sensor.TYPE_PICK_UP_GESTURE
</li>
</ol>

</div>

</div>

<div id="outline-container-3-12-2" class="outline-4">
<h4 id="sec-3-12-2"><span class="section-number-4">3.12.2</span> 使用方法</h4>
<div class="outline-text-4" id="text-3-12-2">

<ol>
<li>向系统申请传感器服务：



<pre class="example">sm = (SensorManager) getSystemService(SENSOR_SERVICE);
</pre>

</li>
<li>利用该服务获取传感器适配器：



<pre class="example">accSensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
if(presSensor == null){
   Log.i(TAG, "no accelerometer");
   return;
}
</pre>

</li>
<li>实例化传感器数据监听器接口：



<pre class="example">SensorEventListener sensorEventListener = new SensorEventListener() {
     @Override
     public void onSensorChanged(SensorEvent event) {
          //todo
     }
     @Override
     public void onAccuracyChanged(Sensor sensor, int accuracy) {
         //todo
     }
}
</pre>

</li>
<li>向传感器服务注册监听器：其中最后一个参数代表多长时间采集一次传感器数据
   (单位us)，系统集成了3个时间
<ul>
<li>SensorManager.SENSOR_DELAY_FASTEST：尽可能快的获取传感器数据；
</li>
<li>SensorManager.SENSOR_DELAY_NORMAL：一般速度；
</li>
<li>SensorManager.SENSOR_DELAY_GAME：适配游戏；
</li>
<li>SensorManager.SENSOR_DELAY_UI：适配UI；



<pre class="example">sm.registerListener(sensorEventListener, accSensor, SensorManager.SENSOR_DELAY_FASTEST);
</pre>

</li>
<li>用完后卸载监听器：



<pre class="example">if(presSensor != null){
     sm.unregisterListener(sensorEventListener);
}
</pre>

</li>
</ol>

</div>
</div>

</div>

<div id="outline-container-3-13" class="outline-3">
<h3 id="sec-3-13"><span class="section-number-3">3.13</span> jni</h3>
<div class="outline-text-3" id="text-3-13">

<p>JNI是java native interface的缩写
</p></div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> rtos</h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> FreeRTOS</h3>
<div class="outline-text-3" id="text-4-1">

<p>FreeRTOS是一个迷你操作系统内核的小型嵌入式系统。作为一个轻量级的操作系统，
功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能等，可基
本满足较小系统的需要。 功能和特点: 
</p><ul>
<li>混合配置选项;
</li>
<li>提供一个高层次的信任代码的完整性;
</li>
<li>目的是小，简单易用;
</li>
<li>以开发C，非常便携代码结构;
</li>
<li>支持两项任务和共同例程;
</li>
<li>强大的执行跟踪功能;
</li>
<li>堆栈溢出检测 ;
</li>
<li>没有软件任务的限制数量;
</li>
<li>没有软件优先事项的限制数量;
</li>
<li>没有施加的限制，优先转让，多个任务可以分配相同的优先权;
</li>
<li>队列，二进制信号量，计数信号灯和递归通信和同步的任务 ;
</li>
<li>Mutexes优先继承权;
</li>
<li>免费开发工具;
</li>
<li>免费嵌入式软件的源代码;
</li>
<li>从一个标准的Windows主机交叉发展;
</li>
</ul>


</div>

<div id="outline-container-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> 术语</h4>
<div class="outline-text-4" id="text-4-1-1">

<ul>
<li>PV操作：P源自于荷兰语parsseren，即英语的pass；V源自于荷兰语verhoog，即英
  语的increment。P(S)V(S)操作是信号量的两个原子操作，S为信号量semaphore，相
  当于一个标志，可以代表一个资源，一个事件等； 
</li>
<li>变量的非原子操作：更新结构体的多个成员变量，或者是更新的变量其长度超过了
  架构体系的自然长度(比如，更新一个16位机上的32位变量)均是非原子操作，如果
  这样的操作被中断，将可能导致数据损坏或者丢失； 
</li>
<li>函数重入：如果一个函数可以安全的被多个任务调用，或在任务与中断中均可调用，
  则这个函数是可以重入的；一般每个任务都单独维护自己的栈空间及其自身在内存
  寄存器组中的值。如果一个函数除访问自己栈空间上分配的数据或是内核寄存器中
  的数据外，会访问其他任何数据，则这个函数是不可重入的。 
</li>
<li>临界区：当某资源需要被多个任务访问使用时，此资源叫临界区，开始访问此资源，
  表示进入临界区；如果要进入临界区，一般安全的做饭是讲所有的中断或者优先级
  关闭，防止在访问临界区资源时，被打断，并且访问临界区资源的程序必须要尽快
  结束； 
</li>
<li>二值信号量：用于同步，可以给某资源配置一个二值信号量，当一个任务要访问某
  资源时，如果此二值信号量不可用，则该任务不可访问该资源，可以通过在中断中
  给予(GIVE)此信号量，则此任务就可以获得(TAKE)该信号量，访问该资源，达到同
  步作用，用于同步的信号量，用完后便丢弃，不再归还； 
</li>
<li>互斥信号量：用于访问一些具有互斥效果的资源，类似二值信号量，当某任务需要
  访问某资源时，需要先获得(TAKE)该资源的令牌(信号量)，用完后，再归还(GIVE)
  该资源的令牌，一个任务只有获得了该资源的令牌后才能访问该资源，否则不允许
  访问进入阻塞状态，用于互斥的信号量必须归还； 
</li>
<li>优先级翻转：指两个不同优先级的任务在允许时，低优先级的任务获得了某资源的
  互斥信号量，并未执行完，此时高优先级的任务也开始运行，并且也要使用该资源，
  从而获取该资源的互斥信号量，然后此时低优先级的任务并未释放该互斥信号量，
  则高优先级的任务进入阻塞状态，等待低优先级的任务执行完释放信号量，从而产
  生了高优先级的任务等待低优先级任务的不合理现象； 
</li>
<li>死锁：当两个任务都在等待被对方持有的资源时，两个任务都无法继续执行，这种
  情况被称为死锁； 
</li>
<li>守护任务：守护任务提供了一个比较好的方法来实现互斥功能，而不用担心会发生
  优先级翻转和死锁，守护任务是对某个资源具有唯一所有权的任务，只有守护任务
  才可直接访问其守护的资源，其他任何任务只能间接的通过守护任务提供访问服务；  
</li>
</ul>

</div>

</div>

<div id="outline-container-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> 源码解读</h4>
<div class="outline-text-4" id="text-4-1-2">


</div>

<div id="outline-container-4-1-2-1" class="outline-5">
<h5 id="sec-4-1-2-1"><span class="section-number-5">4.1.2.1</span> 文件</h5>
<div class="outline-text-5" id="text-4-1-2-1">


</div>

<div id="outline-container-4-1-2-1-1" class="outline-6">
<h6 id="sec-4-1-2-1-1"><span class="section-number-6">4.1.2.1.1</span> FreeRTOS.h</h6>
<div class="outline-text-6" id="text-4-1-2-1-1">

<p>每一个使用了FreeRTOS的程序都需要包含的一个头文件；
</p></div>

</div>

<div id="outline-container-4-1-2-1-2" class="outline-6">
<h6 id="sec-4-1-2-1-2"><span class="section-number-6">4.1.2.1.2</span> projdefs.h</h6>
<div class="outline-text-6" id="text-4-1-2-1-2">

<p>包含了FreeRTOS的一些基本设定，主要定义了如下一些宏定义
</p>


<pre class="example">pdTASK_CODE   //任务函数原型类型
pdFALSE
pdTRUE
pdPASS
pdFAIL
errQUEUE_EMPTY
errQUEUE_FULL
errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
errNO_TASK_TO_RUN
errQUEUE_BLOCKED
errQUEUE_YIELD
</pre>

</div>

</div>

<div id="outline-container-4-1-2-1-3" class="outline-6">
<h6 id="sec-4-1-2-1-3"><span class="section-number-6">4.1.2.1.3</span> FreeRTOSConfig.h</h6>
<div class="outline-text-6" id="text-4-1-2-1-3">

<p>移植的时候要修改的FreeRTOS的全局配置文件; 
</p></div>

</div>

<div id="outline-container-4-1-2-1-4" class="outline-6">
<h6 id="sec-4-1-2-1-4"><span class="section-number-6">4.1.2.1.4</span> portable.h</h6>
<div class="outline-text-6" id="text-4-1-2-1-4">

</div>
</div>

</div>

<div id="outline-container-4-1-2-2" class="outline-5">
<h5 id="sec-4-1-2-2"><span class="section-number-5">4.1.2.2</span> 功能函数</h5>
<div class="outline-text-5" id="text-4-1-2-2">


</div>

<div id="outline-container-4-1-2-2-1" class="outline-6">
<h6 id="sec-4-1-2-2-1"><span class="section-number-6">4.1.2.2.1</span> 任务生成</h6>
<div class="outline-text-6" id="text-4-1-2-2-1">

<p>任务生成使用xTaskGenericCreate函数，并且被宏包装为xTaskCreate； 
</p></div>

</div>

<div id="outline-container-4-1-2-2-2" class="outline-6">
<h6 id="sec-4-1-2-2-2"><span class="section-number-6">4.1.2.2.2</span> 任务删除</h6>
<div class="outline-text-6" id="text-4-1-2-2-2">

</div>

</div>

<div id="outline-container-4-1-2-2-3" class="outline-6">
<h6 id="sec-4-1-2-2-3"><span class="section-number-6">4.1.2.2.3</span> 堆操作</h6>
<div class="outline-text-6" id="text-4-1-2-2-3">

<p>堆并不神秘，在cortex-m0芯片中，堆和栈其实都是用的ram区，只是认为的堆ram区做
了划分，也就是说，完全可以人为的定义一个大的数组来表示堆空间，然后对数组进
行块分割，并且分配给申请者，管理需要释放的数组元素，就是堆空间的分配和释放
操作，基于此，根据堆操作功能复杂度，细化出了heap_1.c、heap_2.c、heap_4.c、
heap_5.c的堆操作功能库，至于heap_3.c完全是使用标准C库的malloc等函数做的封
装，因为标准C库的malloc等函数不是线程安全的函数，需要封装为安全的，所谓的封
装为线程安全的，也就是在执行malloc前后关闭打开中断和调度器；另外对申请的堆
空间地址和长度还涉及到对齐等细节功能操作； 
<a name="heap1-oper" id="heap1-oper"></a>
</p><ul>
<li>heap_1.c: 只有简单的堆空间申请操作，没有释放操作；



<pre class="example">    /* portBYTE_ALIGNMENT:这个常量指示字节对齐数，其默认值为8，即默认以8个
     * 字节进行内存对齐 
     */ 
    /* portBYTE_ALIGNMENT_MASK:这个常量是根据portBYTE_ALIGNMENT的值进行定义的 */
    /* FreeRTOS对堆数组进行地址对齐操作，这样的后果就是要是原本堆数组首地址
     * 没有对齐，则进行对齐操作后就会使堆大小改变了。因此，FreeRTOS对堆数组
     * 的大小进行重新定义。  
     */
#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
/**
 * 数组的总大小(字节为单位)在FreeRTOSConfig.h中由configTOTAL_HEAP_SIZE定义。
 * 以这种方式定义一个巨型数组会让整个应用程序看起来耗费了许多内存
 * ucHeap就是FreeRTOS可以用的整个堆的空间数组，其大小是在FreeRTOSConfig.h中
 * 定义的常量configTOTAL_HEAP_SIZE， 
 * 默认是17*1024，即17KB
 */
static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
///指向下一个还没被用上的内存堆所在的数组下标，由于一开始整个堆都没被用上，
///所以它的默认值为0 
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/
/** 
 * @brief 这种分配方案是将 FreeRTOS 的内存堆空间看作一个简单的数组。
 * 当调用pvPortMalloc()时，则将数组又简单地细分为更小的内存块。函数操作流程
 * 第一步：对齐处理；第二步：分配内存；第三步：勾子函数调用。
 * @param xWantedSize 欲分配的空间大小
 */
void *pvPortMalloc( size_t xWantedSize )
{
    void *pvReturn = NULL;
    static uint8_t *pucAlignedHeap = NULL;
    /* **************************************第一步********************************* */
    /** 用来判断用户所需要的内存大小是否已对齐，例如，在默认情况下（以8个字节对齐），
     * 如果用户申请的内存大小为13个字节，经过和字节对齐掩码进行与操作后的结果为0x0005，即没有对齐；
     * 如果用户申请的内存大小为16个字节，经过和字节对齐掩码进行与操作后的结果为0x0000，即已经对齐。 
     */
    #if portBYTE_ALIGNMENT != 1 
    if( xWantedSize &amp; portBYTE_ALIGNMENT_MASK )
    {
        /** 用户申请内存大小和字节对齐掩码进行与操作后，其结果和需要补齐的字节数相加，
         * 刚好等于字节对齐掩码的值，因此只要用掩码值减去与操作的结果，就可以得到需要补齐的字节数，
         * 这样只要把补齐的字节数加到用户申请的内存大小就可以使其字节对齐 
         */
        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );
    }
    #endif

    /* **************************************第二步********************************* */
    vTaskSuspendAll();
    {
        /** 对这个堆进行对齐工作。这里的对齐和上面说的对齐不是一回事。
         * 这里说的对齐是因为FreeRTOS管理的堆是一个全局数组，
         * 并不能保证数组首地址按portBYTE_ALIGNMENT对齐。
         * 因此FreeRTOS对堆首地址做了这个对齐处理。要留意的是，这个对齐处理只做了一次。
         * 原因是对齐后的堆首地址是一个静态变量，初始值赋为NULL。
         * 而当这个变量为NULL时才进行对齐处理，对齐处理后这个变量就指向堆首地址，
         * 这样在下一次调用pvPortMalloc()时就不会再进行对齐处理了 
         */
        if( pucAlignedHeap == NULL ) /* 第一次初始化heap */
        {
            /* ucHeap往前挪动一个portBYTE_ALIGNMENT长度的地址，做对齐后，才能保证对齐后的地址还在ucHeap数组范围内 */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &amp;ucHeap[ portBYTE_ALIGNMENT ] ) &amp;
                                             ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
        }

        if( ( ( xNextFreeByte + xWantedSize ) &lt; configADJUSTED_HEAP_SIZE ) &amp;&amp;
            ( ( xNextFreeByte + xWantedSize ) &gt; xNextFreeByte ) )/* Check for overflow. */
        {
            /* 记录新分配空间的首地址到pvReturn */
            pvReturn = pucAlignedHeap + xNextFreeByte;
            xNextFreeByte += xWantedSize;
        }
        /** 用于输出内存分配的调试信息，这个宏定义在FreeRTOS.h中，默认为空，
         * 如果需要将这些调试信息输出到串口或其它东西，就可以修改这个宏将信息输出到所需要的地方。 
         */
        traceMALLOC( pvReturn, xWantedSize ); 
    }
    ( void ) xTaskResumeAll();

    /** 当内存分配失败的时候，如果在FreeRTOS.h中有定义宏configUSE_MALLOC_FAILED_HOOK=1，
     * 则会调用一个勾子函数vApplicationMallocFailedHook()。在这个勾子函数中，
     * 用户可以进行其它一些必要的操作 
     */
    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook(); 
        }
    }
    #endif
    return pvReturn;
    }
</pre>

</li>
</ul>

<p><a name="heap2-oper" id="heap2-oper"></a>
</p><ul>
<li>heap_2.c: 同<a href="#heap1-oper">heap_1.c</a>差不多，只是采用一定算法来分配空间，增加了堆释放操作, ；
</li>
</ul>




<pre class="example">void vPortFree( void *pv )
{
    uint8_t *puc = ( uint8_t * ) pv;
    BlockLink_t *pxLink;
    if( pv != NULL )
    {
        /* 寻找这个内存空间的空闲块头 */
        before it. */
        puc -= heapSTRUCT_SIZE;
        byte alignment warnings. */
        pxLink = ( void * ) puc;

        vTaskSuspendAll();
        {
            /* 插入空闲块链表中 */
            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
            /* 修正剩余空间大小 */
            xFreeBytesRemaining += pxLink-&gt;xBlockSize;
            traceFREE( pv, pxLink-&gt;xBlockSize );
        }
        ( void ) xTaskResumeAll();
    }
}
</pre>

<ul>
<li>heap_3.c: 对C标准库的堆操作函数做了线程安全的封装; 
</li>
</ul>

<p>分配函数：
</p>


<pre class="example">void *pvPortMalloc( size_t xWantedSize )
{
    void *pvReturn;
    vTaskSuspendAll();
    {
        pvReturn = malloc( xWantedSize );
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
        }
    }
    #endif
    return pvReturn;
}
</pre>

<p>
释放函数：
</p>


<pre class="example">void vPortFree( void *pv )
{
    if( pv )
    {
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
</pre>

<ul>
<li>heap_4.c: 同<a href="#heap2-oper">heap_2.c</a>差不多，只是分配算法做了更优化，并且相邻空闲空间可以合并；
</li>
</ul>




<pre class="example">void *pvPortMalloc( size_t xWantedSize )
{
    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
    void *pvReturn = NULL;

    vTaskSuspendAll();
    {
        /* If this is the first call to malloc then the heap will require
        initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
        {
            prvHeapInit();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /**
         * 判断用户申请内存大小的最高位是否为0，为0即合法
         * （之前说过，最高位用来标识空闲块的空闲状态，因此最高位为1则说明用户申请的内存大小已超出空闲块的最大大小）
         */
        /* Check the requested block size is not so large that the top bit is
        set.  The top bit of the block size member of the BlockLink_t structure
        is used to determine who owns the block - the application or the
        kernel, so it must be free. */
        if( ( xWantedSize &amp; xBlockAllocatedBit ) == 0 )
        {
            /* The wanted size is increased so it can contain a BlockLink_t
            structure in addition to the requested amount of bytes. */
            if( xWantedSize &gt; 0 )
            {
                xWantedSize += xHeapStructSize; /* 增加block头大小 */

                /* Ensure that blocks are always aligned to the required number
                of bytes. */
                if( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != 0x00 ) /* 对齐操作 */
                {
                    /* Byte alignment required. */
                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );
                    configASSERT( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) == 0 );
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( ( xWantedSize &gt; 0 ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )
            {
                /**
                 * 首先遍历链表，找到第1块能比申请空间大小大的空闲块，修改空闲块的信息，
                 * 记录用户可用的内存首地址。接下来，如果分配出去的空闲块比申请的空间大很多，
                 * 则将该空闲块进行分割，把剩余的部分重新添加到链表中。
                 */
                /* Traverse the list from the start (lowest address) block until
                one of adequate size is found. */
                pxPreviousBlock = &amp;xStart;
                pxBlock = xStart.pxNextFreeBlock;
                while( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != NULL ) )
                {
                    pxPreviousBlock = pxBlock;
                    pxBlock = pxBlock-&gt;pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                was not found. */
                if( pxBlock != pxEnd )
                {
                    /* Return the memory space pointed to - jumping over the
                    BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + xHeapStructSize ); /* 获得真正申请的空间地址 */

                    /* This block is being returned for use so must be taken out
                    of the list of free blocks. */
                    pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock; /* 空闲block链接起来 */

                    /* If the block is larger than required it can be split into
                    two. */
                    if( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE ) /* 见heap_2.c */
                    {
                        /* This block is to be split into two.  Create a new
                        block following the number of bytes requested. The void
                        cast is used to prevent byte alignment warnings from the
                        compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) &amp; portBYTE_ALIGNMENT_MASK ) == 0 );

                        /* Calculate the sizes of two blocks split from the
                        single block. */
                        pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;
                        pxBlock-&gt;xBlockSize = xWantedSize;

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;

                    if( xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining )
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                    by the application and has no "next" block. */
                    pxBlock-&gt;xBlockSize |= xBlockAllocatedBit;
                    pxBlock-&gt;pxNextFreeBlock = NULL;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif

    configASSERT( ( ( ( uint32_t ) pvReturn ) &amp; portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
}
</pre>

</div>

</div>

<div id="outline-container-4-1-2-2-4" class="outline-6">
<h6 id="sec-4-1-2-2-4"><span class="section-number-6">4.1.2.2.4</span> 杂项功能</h6>
<div class="outline-text-6" id="text-4-1-2-2-4">

<p>这些杂项功能大部分都跟平台有关，这里以cortex M系列为例；
</p><ul>
<li>参数断言：使用宏configASSERT, 是空的，需要用户自己写
</li>
<li>提升优先级：static BaseType_t prvRaisePrivilege( void )，通过控制cpu做
  svc调用，svc有相应的号； 
</li>
</ul>




</div>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2016-09-14 13:08:24 中国标准时间</p>
<p class="author">Author: 比克曼</p>
<p class="creator">Org version 7.8.11 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
