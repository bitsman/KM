#+title: 操作系统
#+author: 比克曼
#+latex_class: org-latex-pdf 
#+latex: \newpage 

* android
** base
- 上下文context
  + getApplicationContext():生命周期是整个应用，应用摧毁，它才摧毁。
  + this:代表当前,在Activity当中就是代表当前的Activity，换句话说就是Activity.this在Activity当中可以缩写为this.
  + getApplication():andorid 开发中共享全局数据;
  我们在平时的开发中，有时候可能会需要一些全局数据，来让应用中得所有Activity和View都能访问到，大家在遇到这种情况时，可能
  首先会想到自己定义一个类，然后创建很多静态成员，不过andorid已经为我们提供了这种情况的解决方案：在Android中，有一个名为
  Application的类，我们可以在Activity中使用getApplication()，方法来获得，它是代表我们的应用程序的类，使用它可以获得当前
  应用的主题，资源文件中的内容等，这个类更灵活的一个特性就是可以被我们继承，来添加我们自己的全局属性。
- 判断当前Activity
  #+begin_src java
    ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    ComponentName cn = am.getRunningTasks(1).get(0).topActivity;
    Log.d(TAG, "pkg:"+cn.getPackageName());//显示当前activity所在路径
    Log.d(TAG, "cls:"+cn.getClassName());//路径+类名
    Log.d(TAG, MyActivity.class.getName()); //路径+类名
    Log.d(TAG, MyActivity.class.getSimpleName()); //类名
  #+end_src
*** Bundle
android中的Bundle一般用于携带数据，类似于Map，用于存放key-value键值对，其提供了各种putXx()和getXx()方法，putXx()用于往
Bundle对象中放入数据，getXx()用于从Bundle对象中获取数据。比如Bundle常用与组件之间进行数据传输，我们可以将Bundle设置好数
据后，利用Intent的putExtras()方法将Bundle捆绑到Intent中，然后再传递给别的组件；
*** Intent
Intent可以用于启动别的组件比如Activity和Service等，并在Intent中绑定一定的数据，传递给目标组件。
*** 系统时间
- 获取年月日
  #+begin_src java
    import    java.text.SimpleDateFormat;     
    SimpleDateFormat formatter = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");     
    Date curDate = new Date(System.currentTimeMillis());//获取当前时间     
    String str = formatter.format(curDate);     
  #+end_src
- 获取当前的年月时分
  #+begin_src java
    SimpleDateFormat sDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");     
    String date = sDateFormat.format(new java.util.Date());  
  #+end_src
- 获取当前的年月
  #+begin_src java
    SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM");  
    String date=sdf.format(new java.util.Date());  
  #+end_src
- 获取指定时区的时间
  #+begin_src java
    df = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);
    System.out.println(df.format(new Date()));
  #+end_src
- 确定系统时间制式
  #+begin_src java
     ContentResolver cv = this.getContentResolver();
     String strTimeFormat = android.provider.Settings.System.getString(cv,
                                                            android.provider.Settings.System.TIME_12_24);
     if(strTimeFormat.equals("24")){
        Log.i("activity","24");
     }
  #+end_src
- 取得系统时间日期
  #+begin_src java
    Calendar c = Calendar.getInstance();
    year = c.get(Calendar.YEAR) /*取得系统日期*/
    month = c.grt(Calendar.MONTH)
    day = c.get(Calendar.DAY_OF_MONTH)
    hour = c.get(Calendar.HOUR_OF_DAY);/*取得系统时间*/
    minute = c.get(Calendar.MINUTE)
  #+end_src
- 利用TIMER获取
  #+begin_src java
    Time t=new Time(); // or Time t=new Time("GMT+8"); 加上Time Zone资料。
    t.setToNow(); // 取得系统时间。
    int year = t.year;
    int month = t.month;
    int date = t.monthDay;
    int hour = t.hour; // 0-23
    int minute = t.minute;
    int second = t.second;
  #+end_src
** activity
*** Fragment
Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。针对屏幕尺寸的差距，很多情况下，都是先针对手机开发
一套App，然后拷贝一份，修改布局以适应平板神马超级大屏的。难道无法做到一个App可以同时适应手机和平板么，当然了，必须有啊。
Fragment的出现就是为了解决这样的问题。你可以把Fragment当成Activity的一个界面的一个组成部分，甚至Activity的界面可以完全有
不同的Fragment组成，更帅气的是Fragment拥有自己的生命周期和接收、处理用户的事件，这样就不必在Activity写一堆控件的事件处理
的代码了。更为重要的是，你可以动态的添加、替换和移除某个Fragment; Fragment必须是依存与Activity而存在的，因此Activity的生
命周期会直接影响到Fragment的生命周期, Fragment的生命周期见图\ref{img-fragment-cycle};
#+caption: Fragment生命周期
#+label: img-fragment-cycle
#+attr_latex: placement=[H] scale=0.3
#+begin_src ditaa :file ./img/img-fragment-cycle.png :cmdline -S -E
      Activity          Fragment                         Activity          Fragment
    -----------------------------------                 --------------------------------------
                    +------------+
                    | onAttach   |
                    +-----+------+                        Paused       +--------------+
                          |                    +---------------------->|   onPause    |
                          v                    |                       +------+-------+
                    +------------+             |        -----=----------------+---------------
                    | onCreate   |             |                              |
                    +-----+------+             |                              v
      Created             |                    |          Stopped      +--------------+
                          v                    |                       |   onStop     |
                    +------------+             |                       +------+-------+
                    |onCreateView|             |        ------=---------------+---------------
                    +-----+------+             |                              |
                          |                    |                              v
                          v                    |                       +--------------+
                  +-----------------+          |                       |onDestroyView |
                  |onActivityCreated|          |                       +------+-------+
                  +-------+---------+          |                              |
    ----------------------+---------------     |         Destroyed            v
                          |                    |                       +--------------+
                          v                    |                       |   onDestroy  |
      Started      +-------------+             |                       +------+-------+
                   | onStart     |             |                              |
                   +------+------+             |                              v
    ----------------------+---------------     |                       +--------------+
                          |                    |                       |   onDetach   |
      Resumed             v                    |                       +--------------+
                   +--------------+            |        --------------------------------------
                   |   onResume   |------------+
                   +------+-------+
#+end_src
*** button
- button透明：xml中使用android:background="@android:color/transparent"
*** 下拉菜单
实现某个菜单框里面有多个选项，点击后可以展示各个字符菜单项，点击后可以产生点击事件，可以将某个int值和字符菜单项对应；实
现方法：
1. 定义两个array资源：
  #+begin_src java 
    //字符菜单项
    <string-array name="gps_type_options">
        <item>GPS</item>
        <item>GPS and GLONASS</item>
        <item>GPS and BEIDOU</item>
    </string-array>
  #+end_src
  #+begin_src java
    //int对应值
    <integer-array name="gps_type_values">
        <item>0</item>
        <item>1</item>
        <item>2</item>
    </integer-array>
  #+end_src
2. xml中定义器件
   #+begin_src java
    <Spinner
        android:id="@+id/spinnerType"
        android:layout_width="0dip"
        android:layout_height="wrap_content"
        android:layout_marginRight="8dip"
        android:layout_weight="1" />
   #+end_src
3. 在源文件中获取这2个资源：
   #+begin_src java
    String[] gpsTypeOptions = getResources().getStringArray(R.array.gps_type_options);
	int[] gpsTypeValues = getResources().getIntArray(R.array.gps_type_values);
   #+end_src
4. 绑定两者成adapter:
   #+begin_src java
    private IntArrayAdapter mGPSTypeAdapter;
	mGPSTypeAdapter = new IntArrayAdapter(this, gpsTypeOptions, gpsTypeValues);
   #+end_src
5. 将adapter装配到view上：
   #+begin_src java
    private Spinner mSpinnerType;
    mSpinnerType = (Spinner) findViewById(R.id.spinnerType);
    mSpinnerType.setAdapter(mGPSTypeAdapter);
	mSpinnerType.setOnItemSelectedListener(onItemSelectedListener);
   #+end_src
6. 实现点击事件：
   #+begin_src java
    private OnItemSelectedListener onItemSelectedListener = new OnItemSelectedListener() {
		@Override
		public void onItemSelected(AdapterView<?> adapter,View view,int position,long id) {
			if (adapter == mSpinnerType) {
				mGPSTypePostion = position;
			}
		}
		@Override
		public void onNothingSelected(AdapterView<?> arg0) {}
    };
   #+end_src
*** 复选框
正方形的复选框选项
1. xml中定义器件
   #+begin_src java
    <CheckBox 
      android:id="@+id/cb"
      android:layout_width="wrap_content" 
      android:layout_height="wrap_content"
      android:checked="false"
      android:text="已婚" />
   #+end_src
2. 源码中获取器件
   #+begin_src java
    private CheckBox mCheckKeep;
    mCheckKeep = (CheckBox) findViewById(R.id.checkKeep);
    
   #+end_src
3. 监听事件
   #+begin_src java
    //绑定监听器
    cb.setOnCheckedChangeListener(new OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton arg0, boolean arg1) {
            Toast.makeText(MyActivity.this, 
             arg1?"选中了":"取消了选中"    , Toast.LENGTH_LONG).show();
       }
     });
   #+end_src
4. 也可以查询获得结果
   #+begin_src java
    if(!cb.isChecked()){
    }
   #+end_src
** service
- 在service中启动activity：
  #+begin_src java
    Intent intent = new Intent(getBaseContext(), MtkPlatformTest.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);必须加这句
    startActivity(intent);
  #+end_src
*** Bound Service
要做绑定服务操作，client需要调用bindService() , 调用后，系统将调用server的onBind()方法，这个方法将返回一个IBinder，这个
IBinder正是反给client，client使用此IBinder来调用server实现的各种服务接口，client要取得这个IBinder，需要实现一个接口
ServiceConnection 作为bindService的参数，此ServiceConnection中的方法onServiceConnected将被系统回调(在onBind执行完后)，而
onBind返回的IBinder正是作为参数传给onServiceConnected，这样client就可以在onServiceConnected里面获得该IBinder；
** broadcast
广播机制可以事务处理异步化，可以将事务的处理放在别的地方，然后在另一个地方发送一个Intent，系统会根据此Intent来找到相应的
广播处理方法来处理，步骤如下。
- 设定IntentFilter，可以在manifest文件中设置，也可以在源码中动态设置，实例如下;
  #+begin_src java
    private static IntentFilter makeIntentFilter() {
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION_GATT_CONNECTED);
        intentFilter.addAction(ACTION_GATT_DISCONNECTED);
        intentFilter.addAction(ACTION_GATT_SERVICES_DISCOVERED);
        intentFilter.addAction(ACTION_DATA_AVAILABLE);
        return intentFilter;
    }
  #+end_src
- 设置广播事务处理，实例如下;
  #+begin_src java
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (ACTION_GATT_CONNECTED.equals(action)) {
                //...
            } else if (ACTION_GATT_DISCONNECTED.equals(action)) {
                //...
            } else if (ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
                //...
            } else if (ACTION_DATA_AVAILABLE.equals(action)) {
                //...
            }
        }
    };
  #+end_src
- 注册，将action和事务处理相结合，实例如下;
  #+begin_src java
     registerReceiver(mReceiver, makeIntentFilter());
  #+end_src
- 产生事件源，在别的地方发送消息，实例如下;
  #+begin_src java
    private void broadcastUpdate(final String action) {
        final Intent intent = new Intent(action);
        sendBroadcast(intent);
    }
  #+end_src
** 消息机制
Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队例，应用程序的主线程不断地从这个消息队例中获取消息
(Looper)，然后对这些消息进行处理(Handler)，这样就实现了通过消息来驱动应用程序的执行.
- Message：消息，其中包含了消息ID，消息处理对象以及处理的数据等，由MessageQueue统一列队，终由Handler处理。
- Handler：处理者，负责Message的发送及处理。使用Handler时，需要实现handleMessage(Message msg)方法来对特定的Message进行处理，例如更新UI等。
- MessageQueue：消息队列，用来存放Handler发送过来的消息，并按照FIFO规则执行。当然，存放Message并非实际意义的保存，而是将
  Message以链表的方式串联起来的，等待Looper的抽取。
- Looper：消息泵，不断地从MessageQueue中抽取Message执行。因此，一个MessageQueue需要一个Looper。
- Thread：线程，负责调度整个消息循环，即消息循环的执行场所。
*** Handler
功能主要是跟UI线程交互用，主要有：
1. 用handler发送一个message，然后在handler的线程中来接收、处理该消息，以避免直接在UI主线程中处理事务导致影响UI主线程的其
   他处理工作 ；
2. 你可以将handler对象传给其他进程，以便在其他进程中通过handler给你发送事件；
3. 通过handler的延时发送message，可以延时处理一些事务的处理；
- 线程处理功能：可以使用Handler的post方法，将要处理的事务放在一个thread里面，然后将该线程post到Handler的线程队列中(其实
  这个线程和activity主线程是同一个线程，只是运行了线程的run方法)，则该事务将会在thread里面执行，如果使用
  postDelayed(thread, time)方法，还能设置一个延时time后执行该事务，类似于timer功能；
  实例如下所示。
  #+begin_src java
    //使用handler时首先要创建一个handler
    Handler handler = new Handler();
    //要用handler来处理多线程可以使用runnable接口，这里先定义该接口
    //线程中运行该接口的run函数
    Runnable update_thread = new Runnable(){
        public void run(){
            //线程每次执行时输出"UpdateThread..."文字,且自动换行
            //textview的append功能和Qt中的append类似，不会覆盖前面
            //的内容，只是Qt中的append默认是自动换行模式
            text_view.append("\nUpdateThread...");
            //延时1s后又将线程加入到线程队列中
            handler.postDelayed(update_thread, 1000);
        }
    };
    //将线程接口立刻送到线程队列中
    handler.post(update_thread);
    //将接口从线程队列中移除
    handler.removeCallbacks(update_thread);
  #+end_src
- 异步消息处理功能：同样也是使用上面线程处理功能，将某个线程thread，post到handler的线程队列中，线程队列中处理事务，并可
  以使用handler的sendMessage()，方法向handler中发送message，然后在handler中可以使用handleMessage来处理这个消息；实例如下：
  #+begin_src java
    //创建一个handler，内部完成处理消息方法
    Handler update_progress_bar = new Handler(){
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            //显示进度条
            progress_bar.setProgress(msg.arg1);
            //重新把进程加入到进程队列中
            update_progress_bar.post(update_thread);
        }
    };
    update_progress_bar.post(update_thread);//post线程
    Runnable update_thread = new Runnable() {
        int i = 0;
        public void run() {
            i += 10;
            //首先获得一个消息结构
            Message msg = update_progress_bar.obtainMessage();
            //给消息结构的arg1参数赋值
            msg.arg1 = i;
            //延时1s
            Thread.sleep(1000);
            //把消息发送到消息队列中
            update_progress_bar.sendMessage(msg);
            if(i == 100)
                update_progress_bar.removeCallbacks(update_thread);//移除
        }
    };
  #+end_src

*** Looper

*** Message

** menu
menu标签中item标签的主要属性见表\ref{tbl-menu-bar}
#+caption: android menu bar xml属性说明
#+label: tbl-menu-bar
|-------------------------+------------------------------------------------------------|
| 属性名                  | 说明                                                       |
|-------------------------+------------------------------------------------------------|
| android:orderInCategory | 指每个item优先级，值越大越低，地方不够就会放到overflow中。 |
| android:title           | item的标题。                                               |
| android:icon            | item显示的图标。                                           |
| app:showAsAction        | item显示的方式。                                           |
|-------------------------+------------------------------------------------------------|
* FreeRTOS
FreeRTOS是一个迷你操作系统内核的小型嵌入式系统。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、
内存管理、记录功能等，可基本满足较小系统的需要。 功能和特点:
- 混合配置选项;
- 提供一个高层次的信任代码的完整性;
- 目的是小，简单易用;
- 以开发C，非常便携代码结构;
- 支持两项任务和共同例程;
- 强大的执行跟踪功能;
- 堆栈溢出检测 ;
- 没有软件任务的限制数量;
- 没有软件优先事项的限制数量;
- 没有施加的限制，优先转让，多个任务可以分配相同的优先权;
- 队列，二进制信号量，计数信号灯和递归通信和同步的任务 ;
- Mutexes优先继承权;
- 免费开发工具;
- 免费嵌入式软件的源代码;
- 从一个标准的Windows主机交叉发展;
** 术语
- PV操作：P源自于荷兰语parsseren，即英语的pass；V源自于荷兰语verhoog，即英语的increment。P(S)V(S)操作是信号量的两个原子
  操作，S为信号量semaphore，相当于一个标志，可以代表一个资源，一个事件等；


