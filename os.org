#+title: 操作系统
#+author: 比克曼
#+latex_class: org-latex-pdf 
#+latex: \newpage 

* android
** base
- 上下文context
  + getApplicationContext():生命周期是整个应用，应用摧毁，它才摧毁。
  + this:代表当前,在Activity当中就是代表当前的Activity，换句话说就是Activity.this在Activity当中可以缩写为this.
  + getApplication():andorid 开发中共享全局数据;
  我们在平时的开发中，有时候可能会需要一些全局数据，来让应用中得所有Activity和View都能访问到，大家在遇到这种情况时，可能
  首先会想到自己定义一个类，然后创建很多静态成员，不过andorid已经为我们提供了这种情况的解决方案：在Android中，有一个名为
  Application的类，我们可以在Activity中使用getApplication()，方法来获得，它是代表我们的应用程序的类，使用它可以获得当前
  应用的主题，资源文件中的内容等，这个类更灵活的一个特性就是可以被我们继承，来添加我们自己的全局属性。
- 判断当前Activity
  #+begin_src java
    ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    ComponentName cn = am.getRunningTasks(1).get(0).topActivity;
    Log.d(TAG, "pkg:"+cn.getPackageName());//显示当前activity所在路径
    Log.d(TAG, "cls:"+cn.getClassName());//路径+类名
    Log.d(TAG, MyActivity.class.getName()); //路径+类名
    Log.d(TAG, MyActivity.class.getSimpleName()); //类名
  #+end_src
*** Bundle
android中的Bundle一般用于携带数据，类似于Map，用于存放key-value键值对，其提供了各种putXx()和getXx()方法，putXx()用于往
Bundle对象中放入数据，getXx()用于从Bundle对象中获取数据。比如Bundle常用与组件之间进行数据传输，我们可以将Bundle设置好数
据后，利用Intent的putExtras()方法将Bundle捆绑到Intent中，然后再传递给别的组件；
*** Intent
Intent可以用于启动别的组件比如Activity和Service等，并在Intent中绑定一定的数据，传递给目标组件。
*** 系统时间
- 获取年月日
  #+begin_src java
    import    java.text.SimpleDateFormat;     
    SimpleDateFormat formatter = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");     
    Date curDate = new Date(System.currentTimeMillis());//获取当前时间     
    String str = formatter.format(curDate);     
  #+end_src
- 获取当前的年月时分
  #+begin_src java
    SimpleDateFormat sDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");     
    String date = sDateFormat.format(new java.util.Date());  
  #+end_src
- 获取当前的年月
  #+begin_src java
    SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM");  
    String date=sdf.format(new java.util.Date());  
  #+end_src
- 获取指定时区的时间
  #+begin_src java
    df = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);
    System.out.println(df.format(new Date()));
  #+end_src
- 确定系统时间制式
  #+begin_src java
     ContentResolver cv = this.getContentResolver();
     String strTimeFormat = android.provider.Settings.System.getString(cv,
                                                            android.provider.Settings.System.TIME_12_24);
     if(strTimeFormat.equals("24")){
        Log.i("activity","24");
     }
  #+end_src
- 取得系统时间日期
  #+begin_src java
    Calendar c = Calendar.getInstance();
    year = c.get(Calendar.YEAR) /*取得系统日期*/
    month = c.grt(Calendar.MONTH)
    day = c.get(Calendar.DAY_OF_MONTH)
    hour = c.get(Calendar.HOUR_OF_DAY);/*取得系统时间*/
    minute = c.get(Calendar.MINUTE)
  #+end_src
- 利用TIMER获取
  #+begin_src java
    Time t=new Time(); // or Time t=new Time("GMT+8"); 加上Time Zone资料。
    t.setToNow(); // 取得系统时间。
    int year = t.year;
    int month = t.month;
    int date = t.monthDay;
    int hour = t.hour; // 0-23
    int minute = t.minute;
    int second = t.second;
  #+end_src
** activity
*** Fragment
Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。针对屏幕尺寸的差距，很多情况下，都是先针对手机开发
一套App，然后拷贝一份，修改布局以适应平板神马超级大屏的。难道无法做到一个App可以同时适应手机和平板么，当然了，必须有啊。
Fragment的出现就是为了解决这样的问题。你可以把Fragment当成Activity的一个界面的一个组成部分，甚至Activity的界面可以完全有
不同的Fragment组成，更帅气的是Fragment拥有自己的生命周期和接收、处理用户的事件，这样就不必在Activity写一堆控件的事件处理
的代码了。更为重要的是，你可以动态的添加、替换和移除某个Fragment; Fragment必须是依存与Activity而存在的，因此Activity的生
命周期会直接影响到Fragment的生命周期, Fragment的生命周期见图\ref{img-fragment-cycle};
#+caption: Fragment生命周期
#+label: img-fragment-cycle
#+attr_latex: placement=[H] scale=0.3
#+begin_src ditaa :file ./img/img-fragment-cycle.png :cmdline -S -E
      Activity          Fragment                         Activity          Fragment
    -----------------------------------                 --------------------------------------
                    +------------+
                    | onAttach   |
                    +-----+------+                        Paused       +--------------+
                          |                    +---------------------->|   onPause    |
                          v                    |                       +------+-------+
                    +------------+             |        -----=----------------+---------------
                    | onCreate   |             |                              |
                    +-----+------+             |                              v
      Created             |                    |          Stopped      +--------------+
                          v                    |                       |   onStop     |
                    +------------+             |                       +------+-------+
                    |onCreateView|             |        ------=---------------+---------------
                    +-----+------+             |                              |
                          |                    |                              v
                          v                    |                       +--------------+
                  +-----------------+          |                       |onDestroyView |
                  |onActivityCreated|          |                       +------+-------+
                  +-------+---------+          |                              |
    ----------------------+---------------     |         Destroyed            v
                          |                    |                       +--------------+
                          v                    |                       |   onDestroy  |
      Started      +-------------+             |                       +------+-------+
                   | onStart     |             |                              |
                   +------+------+             |                              v
    ----------------------+---------------     |                       +--------------+
                          |                    |                       |   onDetach   |
      Resumed             v                    |                       +--------------+
                   +--------------+            |        --------------------------------------
                   |   onResume   |------------+
                   +------+-------+
#+end_src
*** button
- button透明：xml中使用android:background="@android:color/transparent"
*** 下拉菜单
实现某个菜单框里面有多个选项，点击后可以展示各个字符菜单项，点击后可以产生点击事件，可以将某个int值和字符菜单项对应；实
现方法：
1. 定义两个array资源：
  #+begin_src java 
    //字符菜单项
    <string-array name="gps_type_options">
        <item>GPS</item>
        <item>GPS and GLONASS</item>
        <item>GPS and BEIDOU</item>
    </string-array>
  #+end_src
  #+begin_src java
    //int对应值
    <integer-array name="gps_type_values">
        <item>0</item>
        <item>1</item>
        <item>2</item>
    </integer-array>
  #+end_src
2. xml中定义器件
   #+begin_src java
    <Spinner
        android:id="@+id/spinnerType"
        android:layout_width="0dip"
        android:layout_height="wrap_content"
        android:layout_marginRight="8dip"
        android:layout_weight="1" />
   #+end_src
3. 在源文件中获取这2个资源：
   #+begin_src java
    String[] gpsTypeOptions = getResources().getStringArray(R.array.gps_type_options);
	int[] gpsTypeValues = getResources().getIntArray(R.array.gps_type_values);
   #+end_src
4. 绑定两者成adapter:
   #+begin_src java
    private IntArrayAdapter mGPSTypeAdapter;
	mGPSTypeAdapter = new IntArrayAdapter(this, gpsTypeOptions, gpsTypeValues);
   #+end_src
5. 将adapter装配到view上：
   #+begin_src java
    private Spinner mSpinnerType;
    mSpinnerType = (Spinner) findViewById(R.id.spinnerType);
    mSpinnerType.setAdapter(mGPSTypeAdapter);
	mSpinnerType.setOnItemSelectedListener(onItemSelectedListener);
   #+end_src
6. 实现点击事件：
   #+begin_src java
    private OnItemSelectedListener onItemSelectedListener = new OnItemSelectedListener() {
		@Override
		public void onItemSelected(AdapterView<?> adapter,View view,int position,long id) {
			if (adapter == mSpinnerType) {
				mGPSTypePostion = position;
			}
		}
		@Override
		public void onNothingSelected(AdapterView<?> arg0) {}
    };
   #+end_src
*** 复选框
正方形的复选框选项
1. xml中定义器件
   #+begin_src java
    <CheckBox 
      android:id="@+id/cb"
      android:layout_width="wrap_content" 
      android:layout_height="wrap_content"
      android:checked="false"
      android:text="已婚" />
   #+end_src
2. 源码中获取器件
   #+begin_src java
    private CheckBox mCheckKeep;
    mCheckKeep = (CheckBox) findViewById(R.id.checkKeep);
    
   #+end_src
3. 监听事件
   #+begin_src java
    //绑定监听器
    cb.setOnCheckedChangeListener(new OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton arg0, boolean arg1) {
            Toast.makeText(MyActivity.this, 
             arg1?"选中了":"取消了选中"    , Toast.LENGTH_LONG).show();
       }
     });
   #+end_src
4. 也可以查询获得结果
   #+begin_src java
    if(!cb.isChecked()){
    }
   #+end_src
** service
- 在service中启动activity：
  #+begin_src java
    Intent intent = new Intent(getBaseContext(), MtkPlatformTest.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);必须加这句
    startActivity(intent);
  #+end_src
*** Bound Service
要做绑定服务操作，client需要调用bindService() , 调用后，系统将调用server的onBind()方法，这个方法将返回一个IBinder，这个
IBinder正是反给client，client使用此IBinder来调用server实现的各种服务接口，client要取得这个IBinder，需要实现一个接口
ServiceConnection 作为bindService的参数，此ServiceConnection中的方法onServiceConnected将被系统回调(在onBind执行完后)，而
onBind返回的IBinder正是作为参数传给onServiceConnected，这样client就可以在onServiceConnected里面获得该IBinder；
** broadcast
广播机制可以事务处理异步化，可以将事务的处理放在别的地方，然后在另一个地方发送一个Intent，系统会根据此Intent来找到相应的
广播处理方法来处理，步骤如下。
- 设定IntentFilter，可以在manifest文件中设置，也可以在源码中动态设置，实例如下;
  #+begin_src java
    private static IntentFilter makeIntentFilter() {
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION_GATT_CONNECTED);
        intentFilter.addAction(ACTION_GATT_DISCONNECTED);
        intentFilter.addAction(ACTION_GATT_SERVICES_DISCOVERED);
        intentFilter.addAction(ACTION_DATA_AVAILABLE);
        return intentFilter;
    }
  #+end_src
- 设置广播事务处理，实例如下;
  #+begin_src java
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (ACTION_GATT_CONNECTED.equals(action)) {
                //...
            } else if (ACTION_GATT_DISCONNECTED.equals(action)) {
                //...
            } else if (ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
                //...
            } else if (ACTION_DATA_AVAILABLE.equals(action)) {
                //...
            }
        }
    };
  #+end_src
- 注册，将action和事务处理相结合，实例如下;
  #+begin_src java
     registerReceiver(mReceiver, makeIntentFilter());
  #+end_src
- 产生事件源，在别的地方发送消息，实例如下;
  #+begin_src java
    private void broadcastUpdate(final String action) {
        final Intent intent = new Intent(action);
        sendBroadcast(intent);
    }
  #+end_src
** 消息机制
Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队例，应用程序的主线程不断地从这个消息队例中获取消息
(Looper)，然后对这些消息进行处理(Handler)，这样就实现了通过消息来驱动应用程序的执行.
- Message：消息，其中包含了消息ID，消息处理对象以及处理的数据等，由MessageQueue统一列队，终由Handler处理。
- Handler：处理者，负责Message的发送及处理。使用Handler时，需要实现handleMessage(Message msg)方法来对特定的Message进行处理，例如更新UI等。
- MessageQueue：消息队列，用来存放Handler发送过来的消息，并按照FIFO规则执行。当然，存放Message并非实际意义的保存，而是将
  Message以链表的方式串联起来的，等待Looper的抽取。
- Looper：消息泵，不断地从MessageQueue中抽取Message执行。因此，一个MessageQueue需要一个Looper。
- Thread：线程，负责调度整个消息循环，即消息循环的执行场所。
*** Handler
功能主要是跟UI线程交互用，主要有：
1. 用handler发送一个message，然后在handler的线程中来接收、处理该消息，以避免直接在UI主线程中处理事务导致影响UI主线程的其
   他处理工作 ；
2. 你可以将handler对象传给其他进程，以便在其他进程中通过handler给你发送事件；
3. 通过handler的延时发送message，可以延时处理一些事务的处理；
- 线程处理功能：可以使用Handler的post方法，将要处理的事务放在一个thread里面，然后将该线程post到Handler的线程队列中(其实
  这个线程和activity主线程是同一个线程，只是运行了线程的run方法)，则该事务将会在thread里面执行，如果使用
  postDelayed(thread, time)方法，还能设置一个延时time后执行该事务，类似于timer功能；
  实例如下所示。
  #+begin_src java
    //使用handler时首先要创建一个handler
    Handler handler = new Handler();
    //要用handler来处理多线程可以使用runnable接口，这里先定义该接口
    //线程中运行该接口的run函数
    Runnable update_thread = new Runnable(){
        public void run(){
            //线程每次执行时输出"UpdateThread..."文字,且自动换行
            //textview的append功能和Qt中的append类似，不会覆盖前面
            //的内容，只是Qt中的append默认是自动换行模式
            text_view.append("\nUpdateThread...");
            //延时1s后又将线程加入到线程队列中
            handler.postDelayed(update_thread, 1000);
        }
    };
    //将线程接口立刻送到线程队列中
    handler.post(update_thread);
    //将接口从线程队列中移除
    handler.removeCallbacks(update_thread);
  #+end_src
- 异步消息处理功能：同样也是使用上面线程处理功能，将某个线程thread，post到handler的线程队列中，线程队列中处理事务，并可
  以使用handler的sendMessage()，方法向handler中发送message，然后在handler中可以使用handleMessage来处理这个消息；实例如下：
  #+begin_src java
    //创建一个handler，内部完成处理消息方法
    Handler update_progress_bar = new Handler(){
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            //显示进度条
            progress_bar.setProgress(msg.arg1);
            //重新把进程加入到进程队列中
            update_progress_bar.post(update_thread);
        }
    };
    update_progress_bar.post(update_thread);//post线程
    Runnable update_thread = new Runnable() {
        int i = 0;
        public void run() {
            i += 10;
            //首先获得一个消息结构
            Message msg = update_progress_bar.obtainMessage();
            //给消息结构的arg1参数赋值
            msg.arg1 = i;
            //延时1s
            Thread.sleep(1000);
            //把消息发送到消息队列中
            update_progress_bar.sendMessage(msg);
            if(i == 100)
                update_progress_bar.removeCallbacks(update_thread);//移除
        }
    };
  #+end_src

*** Looper

*** Message

** menu
menu标签中item标签的主要属性见表\ref{tbl-menu-bar}
#+caption: android menu bar xml属性说明
#+label: tbl-menu-bar
|-------------------------+------------------------------------------------------------|
| 属性名                  | 说明                                                       |
|-------------------------+------------------------------------------------------------|
| android:orderInCategory | 指每个item优先级，值越大越低，地方不够就会放到overflow中。 |
| android:title           | item的标题。                                               |
| android:icon            | item显示的图标。                                           |
| app:showAsAction        | item显示的方式。                                           |
|-------------------------+------------------------------------------------------------|
* FreeRTOS
FreeRTOS是一个迷你操作系统内核的小型嵌入式系统。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、
内存管理、记录功能等，可基本满足较小系统的需要。 功能和特点:
- 混合配置选项;
- 提供一个高层次的信任代码的完整性;
- 目的是小，简单易用;
- 以开发C，非常便携代码结构;
- 支持两项任务和共同例程;
- 强大的执行跟踪功能;
- 堆栈溢出检测 ;
- 没有软件任务的限制数量;
- 没有软件优先事项的限制数量;
- 没有施加的限制，优先转让，多个任务可以分配相同的优先权;
- 队列，二进制信号量，计数信号灯和递归通信和同步的任务 ;
- Mutexes优先继承权;
- 免费开发工具;
- 免费嵌入式软件的源代码;
- 从一个标准的Windows主机交叉发展;
** 术语
- PV操作：P源自于荷兰语parsseren，即英语的pass；V源自于荷兰语verhoog，即英语的increment。P(S)V(S)操作是信号量的两个原子
  操作，S为信号量semaphore，相当于一个标志，可以代表一个资源，一个事件等；
- 变量的非原子操作：更新结构体的多个成员变量，或者是更新的变量其长度超过了架构体系的自然长度(比如，更新一个16位机上的32
  位变量)均是非原子操作，如果这样的操作被中断，将可能导致数据损坏或者丢失；
- 函数重入：如果一个函数可以安全的被多个任务调用，或在任务与中断中均可调用，则这个函数是可以重入的；一般每个任务都单独维
  护自己的栈空间及其自身在内存寄存器组中的值。如果一个函数除访问自己栈空间上分配的数据或是内核寄存器中的数据外，会访问其
  他任何数据，则这个函数是不可重入的。
- 临界区：当某资源需要被多个任务访问使用时，此资源叫临界区，开始访问此资源，表示进入临界区；如果要进入临界区，一般安全的
  做饭是讲所有的中断或者优先级关闭，防止在访问临界区资源时，被打断，并且访问临界区资源的程序必须要尽快结束；
- 二值信号量：用于同步，可以给某资源配置一个二值信号量，当一个任务要访问某资源时，如果此二值信号量不可用，则该任务不可访
  问该资源，可以通过在中断中给予(GIVE)此信号量，则此任务就可以获得(TAKE)该信号量，访问该资源，达到同步作用，用于同步的信
  号量，用完后便丢弃，不再归还；
- 互斥信号量：用于访问一些具有互斥效果的资源，类似二值信号量，当某任务需要访问某资源时，需要先获得(TAKE)该资源的令牌(信
  号量)，用完后，再归还(GIVE)该资源的令牌，一个任务只有获得了该资源的令牌后才能访问该资源，否则不允许访问进入阻塞状态，
  用于互斥的信号量必须归还；
- 优先级翻转：指两个不同优先级的任务在允许时，低优先级的任务获得了某资源的互斥信号量，并未执行完，此时高优先级的任务也开
  始运行，并且也要使用该资源，从而获取该资源的互斥信号量，然后此时低优先级的任务并未释放该互斥信号量，则高优先级的任务进
  入阻塞状态，等待低优先级的任务执行完释放信号量，从而产生了高优先级的任务等待低优先级任务的不合理现象；
- 死锁：当两个任务都在等待被对方持有的资源时，两个任务都无法继续执行，这种情况被称为死锁；
- 守护任务：守护任务提供了一个比较好的方法来实现互斥功能，而不用担心会发生优先级翻转和死锁，守护任务是对某个资源具有唯一
  所有权的任务，只有守护任务才可以直接访问其守护的资源，其他任何任务只能间接的通过守护任务提供访问服务；
** 源码解读
*** 文件
**** FreeRTOS.h
每一个使用了FreeRTOS的程序都需要包含的一个头文件；
**** projdefs.h
包含了FreeRTOS的一些基本设定，主要定义了如下一些宏定义
#+begin_src c
    pdTASK_CODE   //任务函数原型类型
    pdFALSE
    pdTRUE
    pdPASS
    pdFAIL
    errQUEUE_EMPTY
    errQUEUE_FULL
    errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
    errNO_TASK_TO_RUN
    errQUEUE_BLOCKED
    errQUEUE_YIELD
#+end_src
**** FreeRTOSConfig.h
移植的时候要修改的FreeRTOS的全局配置文件; 
**** portable.h
*** 功能函数
**** 任务生成
任务生成使用xTaskGenericCreate函数，并且被宏包装为xTaskCreate；
**** 任务删除

**** 杂项功能
这些杂项功能大部分都跟平台有关，这里以cortex M系列为例；
- 参数断言：使用宏configASSERT, 但是不知道为什么是空的；
- 提升优先级：static BaseType_t prvRaisePrivilege( void )，通过控制cpu做svc调用，svc有相应的号；
- 堆初始化：static void prvHeapInit( void ), 



