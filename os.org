#+title: 操作系统
#+author: 比克曼
#+latex_class: org-latex-pdf 
#+latex: \newpage 

* android
** base
- 上下文context
  + getApplicationContext():生命周期是整个应用，应用摧毁，它才摧毁。
  + this:代表当前,在Activity当中就是代表当前的Activity，换句话说就是Activity.this在Activity当中可以缩写为this.
  + getApplication():andorid 开发中共享全局数据;
  我们在平时的开发中，有时候可能会需要一些全局数据，来让应用中得所有Activity和View都能访问到，大家在遇到这种情况时，可能
  首先会想到自己定义一个类，然后创建很多静态成员，不过andorid已经为我们提供了这种情况的解决方案：在Android中，有一个名为
  Application的类，我们可以在Activity中使用getApplication()，方法来获得，它是代表我们的应用程序的类，使用它可以获得当前
  应用的主题，资源文件中的内容等，这个类更灵活的一个特性就是可以被我们继承，来添加我们自己的全局属性。
- 判断当前Activity
  #+begin_src java
    ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    ComponentName cn = am.getRunningTasks(1).get(0).topActivity;
    Log.d(TAG, "pkg:"+cn.getPackageName());//显示当前activity所在路径
    Log.d(TAG, "cls:"+cn.getClassName());//路径+类名
    Log.d(TAG, MyActivity.class.getName()); //路径+类名
    Log.d(TAG, MyActivity.class.getSimpleName()); //类名
  #+end_src
*** Bundle
android中的Bundle一般用于携带数据，类似于Map，用于存放key-value键值对，其提供了各种putXx()和getXx()方法，putXx()用于往
Bundle对象中放入数据，getXx()用于从Bundle对象中获取数据。比如Bundle常用与组件之间进行数据传输，我们可以将Bundle设置好数
据后，利用Intent的putExtras()方法将Bundle捆绑到Intent中，然后再传递给别的组件；
*** Intent
Intent可以用于启动别的组件比如Activity和Service等，并在Intent中绑定一定的数据，传递给目标组件。
*** 系统时间
- 获取年月日
  #+begin_src java
    import    java.text.SimpleDateFormat;     
    SimpleDateFormat formatter = new SimpleDateFormat("yyyy年MM月dd日HH:mm:ss");     
    Date curDate = new Date(System.currentTimeMillis());//获取当前时间     
    String str = formatter.format(curDate);     
  #+end_src
- 获取当前的年月时分
  #+begin_src java
    SimpleDateFormat sDateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");     
    String date = sDateFormat.format(new java.util.Date());  
  #+end_src
- 获取当前的年月
  #+begin_src java
    SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM");  
    String date=sdf.format(new java.util.Date());  
  #+end_src
- 获取指定时区的时间
  #+begin_src java
    df = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL,Locale.CHINA);
    System.out.println(df.format(new Date()));
  #+end_src
- 确定系统时间制式
  #+begin_src java
     ContentResolver cv = this.getContentResolver();
     String strTimeFormat = android.provider.Settings.System.getString(cv,
                                                            android.provider.Settings.System.TIME_12_24);
     if(strTimeFormat.equals("24")){
        Log.i("activity","24");
     }
  #+end_src
- 取得系统时间日期
  #+begin_src java
    Calendar c = Calendar.getInstance();
    year = c.get(Calendar.YEAR) /*取得系统日期*/
    month = c.grt(Calendar.MONTH)
    day = c.get(Calendar.DAY_OF_MONTH)
    hour = c.get(Calendar.HOUR_OF_DAY);/*取得系统时间*/
    minute = c.get(Calendar.MINUTE)
  #+end_src
- 利用TIMER获取
  #+begin_src java
    Time t=new Time(); // or Time t=new Time("GMT+8"); 加上Time Zone资料。
    t.setToNow(); // 取得系统时间。
    int year = t.year;
    int month = t.month;
    int date = t.monthDay;
    int hour = t.hour; // 0-23
    int minute = t.minute;
    int second = t.second;
  #+end_src
** activity
*** Fragment
Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。针对屏幕尺寸的差距，很多情况下，都是先针对手机开发
一套App，然后拷贝一份，修改布局以适应平板神马超级大屏的。难道无法做到一个App可以同时适应手机和平板么，当然了，必须有啊。
Fragment的出现就是为了解决这样的问题。你可以把Fragment当成Activity的一个界面的一个组成部分，甚至Activity的界面可以完全有
不同的Fragment组成，更帅气的是Fragment拥有自己的生命周期和接收、处理用户的事件，这样就不必在Activity写一堆控件的事件处理
的代码了。更为重要的是，你可以动态的添加、替换和移除某个Fragment; Fragment必须是依存与Activity而存在的，因此Activity的生
命周期会直接影响到Fragment的生命周期, Fragment的生命周期见图\ref{img-fragment-cycle};
#+caption: Fragment生命周期
#+label: img-fragment-cycle
#+attr_latex: placement=[H] scale=0.3
#+begin_src ditaa :file ./img/img-fragment-cycle.png :cmdline -S -E
      Activity          Fragment                         Activity          Fragment
    -----------------------------------                 --------------------------------------
                    +------------+
                    | onAttach   |
                    +-----+------+                        Paused       +--------------+
                          |                    +---------------------->|   onPause    |
                          v                    |                       +------+-------+
                    +------------+             |        -----=----------------+---------------
                    | onCreate   |             |                              |
                    +-----+------+             |                              v
      Created             |                    |          Stopped      +--------------+
                          v                    |                       |   onStop     |
                    +------------+             |                       +------+-------+
                    |onCreateView|             |        ------=---------------+---------------
                    +-----+------+             |                              |
                          |                    |                              v
                          v                    |                       +--------------+
                  +-----------------+          |                       |onDestroyView |
                  |onActivityCreated|          |                       +------+-------+
                  +-------+---------+          |                              |
    ----------------------+---------------     |         Destroyed            v
                          |                    |                       +--------------+
                          v                    |                       |   onDestroy  |
      Started      +-------------+             |                       +------+-------+
                   | onStart     |             |                              |
                   +------+------+             |                              v
    ----------------------+---------------     |                       +--------------+
                          |                    |                       |   onDetach   |
      Resumed             v                    |                       +--------------+
                   +--------------+            |        --------------------------------------
                   |   onResume   |------------+
                   +------+-------+
#+end_src
*** button
- button透明：xml中使用android:background="@android:color/transparent"
*** 下拉菜单
实现某个菜单框里面有多个选项，点击后可以展示各个字符菜单项，点击后可以产生点击事件，可以将某个int值和字符菜单项对应；实
现方法：
1. 定义两个array资源：
  #+begin_src java 
    //字符菜单项
    <string-array name="gps_type_options">
        <item>GPS</item>
        <item>GPS and GLONASS</item>
        <item>GPS and BEIDOU</item>
    </string-array>
  #+end_src
  #+begin_src java
    //int对应值
    <integer-array name="gps_type_values">
        <item>0</item>
        <item>1</item>
        <item>2</item>
    </integer-array>
  #+end_src
2. xml中定义器件
   #+begin_src java
    <Spinner
        android:id="@+id/spinnerType"
        android:layout_width="0dip"
        android:layout_height="wrap_content"
        android:layout_marginRight="8dip"
        android:layout_weight="1" />
   #+end_src
3. 在源文件中获取这2个资源：
   #+begin_src java
    String[] gpsTypeOptions = getResources().getStringArray(R.array.gps_type_options);
	int[] gpsTypeValues = getResources().getIntArray(R.array.gps_type_values);
   #+end_src
4. 绑定两者成adapter:
   #+begin_src java
    private IntArrayAdapter mGPSTypeAdapter;
	mGPSTypeAdapter = new IntArrayAdapter(this, gpsTypeOptions, gpsTypeValues);
   #+end_src
5. 将adapter装配到view上：
   #+begin_src java
    private Spinner mSpinnerType;
    mSpinnerType = (Spinner) findViewById(R.id.spinnerType);
    mSpinnerType.setAdapter(mGPSTypeAdapter);
	mSpinnerType.setOnItemSelectedListener(onItemSelectedListener);
   #+end_src
6. 实现点击事件：
   #+begin_src java
    private OnItemSelectedListener onItemSelectedListener = new OnItemSelectedListener() {
		@Override
		public void onItemSelected(AdapterView<?> adapter,View view,int position,long id) {
			if (adapter == mSpinnerType) {
				mGPSTypePostion = position;
			}
		}
		@Override
		public void onNothingSelected(AdapterView<?> arg0) {}
    };
   #+end_src
*** 复选框
正方形的复选框选项
1. xml中定义器件
   #+begin_src java
    <CheckBox 
      android:id="@+id/cb"
      android:layout_width="wrap_content" 
      android:layout_height="wrap_content"
      android:checked="false"
      android:text="已婚" />
   #+end_src
2. 源码中获取器件
   #+begin_src java
    private CheckBox mCheckKeep;
    mCheckKeep = (CheckBox) findViewById(R.id.checkKeep);
    
   #+end_src
3. 监听事件
   #+begin_src java
    //绑定监听器
    cb.setOnCheckedChangeListener(new OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton arg0, boolean arg1) {
            Toast.makeText(MyActivity.this, 
             arg1?"选中了":"取消了选中"    , Toast.LENGTH_LONG).show();
       }
     });
   #+end_src
4. 也可以查询获得结果
   #+begin_src java
    if(!cb.isChecked()){
    }
   #+end_src
** service
- 在service中启动activity：
  #+begin_src java
    Intent intent = new Intent(getBaseContext(), MtkPlatformTest.class);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);必须加这句
    startActivity(intent);
  #+end_src
*** Bound Service
要做绑定服务操作，client需要调用bindService() , 调用后，系统将调用server的onBind()方法，这个方法将返回一个IBinder，这个
IBinder正是反给client，client使用此IBinder来调用server实现的各种服务接口，client要取得这个IBinder，需要实现一个接口
ServiceConnection 作为bindService的参数，此ServiceConnection中的方法onServiceConnected将被系统回调(在onBind执行完后)，而
onBind返回的IBinder正是作为参数传给onServiceConnected，这样client就可以在onServiceConnected里面获得该IBinder；
** broadcast
广播机制可以事务处理异步化，可以将事务的处理放在别的地方，然后在另一个地方发送一个Intent，系统会根据此Intent来找到相应的
广播处理方法来处理，步骤如下。
- 设定IntentFilter，可以在manifest文件中设置，也可以在源码中动态设置，实例如下;
  #+begin_src java
    private static IntentFilter makeIntentFilter() {
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION_GATT_CONNECTED);
        intentFilter.addAction(ACTION_GATT_DISCONNECTED);
        intentFilter.addAction(ACTION_GATT_SERVICES_DISCOVERED);
        intentFilter.addAction(ACTION_DATA_AVAILABLE);
        return intentFilter;
    }
  #+end_src
- 设置广播事务处理，实例如下;
  #+begin_src java
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (ACTION_GATT_CONNECTED.equals(action)) {
                //...
            } else if (ACTION_GATT_DISCONNECTED.equals(action)) {
                //...
            } else if (ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
                //...
            } else if (ACTION_DATA_AVAILABLE.equals(action)) {
                //...
            }
        }
    };
  #+end_src
- 注册，将action和事务处理相结合，实例如下;
  #+begin_src java
     registerReceiver(mReceiver, makeIntentFilter());
  #+end_src
- 产生事件源，在别的地方发送消息，实例如下;
  #+begin_src java
    private void broadcastUpdate(final String action) {
        final Intent intent = new Intent(action);
        sendBroadcast(intent);
    }
  #+end_src
** 消息机制
Android应用程序是通过消息来驱动的，系统为每一个应用程序维护一个消息队例，应用程序的主线程不断地从这个消息队例中获取消息
(Looper)，然后对这些消息进行处理(Handler)，这样就实现了通过消息来驱动应用程序的执行.
- Message：消息，其中包含了消息ID，消息处理对象以及处理的数据等，由MessageQueue统一列队，终由Handler处理。
- Handler：处理者，负责Message的发送及处理。使用Handler时，需要实现handleMessage(Message msg)方法来对特定的Message进行处理，例如更新UI等。
- MessageQueue：消息队列，用来存放Handler发送过来的消息，并按照FIFO规则执行。当然，存放Message并非实际意义的保存，而是将
  Message以链表的方式串联起来的，等待Looper的抽取。
- Looper：消息泵，不断地从MessageQueue中抽取Message执行。因此，一个MessageQueue需要一个Looper。
- Thread：线程，负责调度整个消息循环，即消息循环的执行场所。
*** Handler
功能主要是跟UI线程交互用，主要有：
1. 用handler发送一个message，然后在handler的线程中来接收、处理该消息，以避免直接在UI主线程中处理事务导致影响UI主线程的其
   他处理工作 ；
2. 你可以将handler对象传给其他进程，以便在其他进程中通过handler给你发送事件；
3. 通过handler的延时发送message，可以延时处理一些事务的处理；
- 线程处理功能：可以使用Handler的post方法，将要处理的事务放在一个thread里面，然后将该线程post到Handler的线程队列中(其实
  这个线程和activity主线程是同一个线程，只是运行了线程的run方法)，则该事务将会在thread里面执行，如果使用
  postDelayed(thread, time)方法，还能设置一个延时time后执行该事务，类似于timer功能；
  实例如下所示。
  #+begin_src java
    //使用handler时首先要创建一个handler
    Handler handler = new Handler();
    //要用handler来处理多线程可以使用runnable接口，这里先定义该接口
    //线程中运行该接口的run函数
    Runnable update_thread = new Runnable(){
        public void run(){
            //线程每次执行时输出"UpdateThread..."文字,且自动换行
            //textview的append功能和Qt中的append类似，不会覆盖前面
            //的内容，只是Qt中的append默认是自动换行模式
            text_view.append("\nUpdateThread...");
            //延时1s后又将线程加入到线程队列中
            handler.postDelayed(update_thread, 1000);
        }
    };
    //将线程接口立刻送到线程队列中
    handler.post(update_thread);
    //将接口从线程队列中移除
    handler.removeCallbacks(update_thread);
  #+end_src
- 异步消息处理功能：同样也是使用上面线程处理功能，将某个线程thread，post到handler的线程队列中，线程队列中处理事务，并可
  以使用handler的sendMessage()，方法向handler中发送message，然后在handler中可以使用handleMessage来处理这个消息；实例如下：
  #+begin_src java
    //创建一个handler，内部完成处理消息方法
    Handler update_progress_bar = new Handler(){
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            //显示进度条
            progress_bar.setProgress(msg.arg1);
            //重新把进程加入到进程队列中
            update_progress_bar.post(update_thread);
        }
    };
    update_progress_bar.post(update_thread);//post线程
    Runnable update_thread = new Runnable() {
        int i = 0;
        public void run() {
            i += 10;
            //首先获得一个消息结构
            Message msg = update_progress_bar.obtainMessage();
            //给消息结构的arg1参数赋值
            msg.arg1 = i;
            //延时1s
            Thread.sleep(1000);
            //把消息发送到消息队列中
            update_progress_bar.sendMessage(msg);
            if(i == 100)
                update_progress_bar.removeCallbacks(update_thread);//移除
        }
    };
  #+end_src

*** Looper

*** Message

** menu
menu标签中item标签的主要属性见表\ref{tbl-menu-bar}
#+caption: android menu bar xml属性说明
#+label: tbl-menu-bar
|-------------------------+------------------------------------------------------------|
| 属性名                  | 说明                                                       |
|-------------------------+------------------------------------------------------------|
| android:orderInCategory | 指每个item优先级，值越大越低，地方不够就会放到overflow中。 |
| android:title           | item的标题。                                               |
| android:icon            | item显示的图标。                                           |
| app:showAsAction        | item显示的方式。                                           |
|-------------------------+------------------------------------------------------------|
** gps
*** 组件
- LocationManagerService：简称LMS，统一管理android平台中能够提供位置服务的相关模块；
- LocationManager：简称LM，为需要使用位置服务的应用程序服务，LMS和LM通过binder进行交互；
- LocationProvider：简称LP，表示android平台中能够提供位置服务的相关模块的统称，在所有位置提供者中，android framework实现
  了其中的PassiveProvider和GpsLocationProvider，这两个LP由LMS创建并允许在系统进程中；
- LocationProviderInterface：LP必须实现这个接口，这些接口对应的对象实例由LMS来创建和管理；
- NetworkLocationProvider：由网络提供的位置服务，android原生代码中不提供相关功能，一般第三方厂商会提供；
- GMS：GoogleMobileService，由Google提供的NetworkLocationProvider，国内的一般由百度提供；
- ILocationProviderProxy：由于一些LP是由第三方提供，他们运行在应用程序所在的进程中，所以系统定了这个接口使LMS管理这些由
  应用程序提供的位置服务；
- LocationProviderBase：第三方提供LP，必须实现这个抽象类；
- FusedLocationProvider：它自身不提供位置信息，而是综合GpsLP和NetworkLP的位置信息，然后向使用者提供最符合使用者需求的数
  据，平衡电量消耗和数据精度要求；
- GeocodeProxy：由于需要将位置信息和地址相互转换，而有些位置信息由第三方提供，所以LMS利用这个和第三方应用中实现
  GeocodeProxy的对象进行交互。
*** 操作
1. 先创建一个LocationManager对象，用于和LMS交互；
2. 然后调用LocationManager的requestLocationUpdates以设置一个回调接口对象LocationListener，同时指出要使用哪个LP，或者指定
   定位精度，由系统决定选择LP；
3. 当LP更新相关信息后，LocationListener对应的函数将被调用，应用程序可以在这些回调函数中做相应处理；
4. 如果应用程序需要在位置和地址信息做转换，则使用Geocoder类提供的函数；
**** LocationManager
LocationMangager，位置管理器。要想操作定位相关设备，必须先定义个LocationManager。我们可以通过如下代码创建LocationManger
对象。
#+begin_src java
LocationManger locationManager=(LocationManager)this.getSystemService(Context.LOCATION_SERVICE); 
#+end_src
**** LocationListener
LocationListener，位置监听，监听位置变化，监听设备开关与状态。
#+begin_src java
private LocationListener locationListener=new LocationListener() {
        /**
         * 位置信息变化时触发
         */
        public void onLocationChanged(Location location) {
            updateView(location);
            Log.i(TAG, "时间："+location.getTime()); 
            Log.i(TAG, "经度："+location.getLongitude()); 
            Log.i(TAG, "纬度："+location.getLatitude()); 
            Log.i(TAG, "海拔："+location.getAltitude()); 
        }
        
        /**
         * GPS状态变化时触发
         */
        public void onStatusChanged(String provider, int status, Bundle extras) {
            switch (status) {
            //GPS状态为可见时
            case LocationProvider.AVAILABLE:
                Log.i(TAG, "当前GPS状态为可见状态");
                break;
            //GPS状态为服务区外时
            case LocationProvider.OUT_OF_SERVICE:
                Log.i(TAG, "当前GPS状态为服务区外状态");
                break;
            //GPS状态为暂停服务时
            case LocationProvider.TEMPORARILY_UNAVAILABLE:
                Log.i(TAG, "当前GPS状态为暂停服务状态");
                break;
            }
        }
        /**
         * GPS开启时触发
         */
        public void onProviderEnabled(String provider) {
            Location location=lm.getLastKnownLocation(provider);
            updateView(location);
        }
        /**
         * GPS禁用时触发
         */
        public void onProviderDisabled(String provider) {
            updateView(null);
        }
    };
#+end_src
**** Location
Location，位置信息，通过Location可以获取时间、经纬度、海拔等位置信息。上面采用locationListener里面的onLocationChanged()
来获取location，下面讲述如何主动获取location。
#+begin_src java
Location location=locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
system.out.println("时间："+location.getTime());
system.out.println("经度："+location.getLongitude());  
#+end_src
**** GpsStatus.Listener
GpsStatus.Listener ，GPS状态监听，包括GPS启动、停止、第一次定位、卫星变化等事件。
#+begin_src java
//状态监听
    GpsStatus.Listener listener = new GpsStatus.Listener() {
        public void onGpsStatusChanged(int event) {
            switch (event) {
            //第一次定位
            case GpsStatus.GPS_EVENT_FIRST_FIX:
                Log.i(TAG, "第一次定位");
                break;
            //卫星状态改变
            case GpsStatus.GPS_EVENT_SATELLITE_STATUS:
                Log.i(TAG, "卫星状态改变");
                //获取当前状态
                GpsStatus gpsStatus=lm.getGpsStatus(null);
                //获取卫星颗数的默认最大值
                int maxSatellites = gpsStatus.getMaxSatellites();
                //创建一个迭代器保存所有卫星 
                Iterator<GpsSatellite> iters = gpsStatus.getSatellites().iterator();
                int count = 0;     
                while (iters.hasNext() && count <= maxSatellites) {     
                    GpsSatellite s = iters.next();     
                    count++;     
                }   
                System.out.println("搜索到："+count+"颗卫星");
                break;
            //定位启动
            case GpsStatus.GPS_EVENT_STARTED:
                Log.i(TAG, "定位启动");
                break;
            //定位结束
            case GpsStatus.GPS_EVENT_STOPPED:
                Log.i(TAG, "定位结束");
                break;
            }
        };
    };
//绑定监听状态
lm.addGpsStatusListener(listener);
#+end_src
**** GpsStatus
GpsStatus，GPS状态信息，上面在卫星状态变化时，我们就用到了GpsStatus。
#+begin_src java
//实例化    
GpsStatus gpsStatus = locationManager.getGpsStatus(null); // 获取当前状态    
//获取默认最大卫星数    
int maxSatellites = gpsStatus.getMaxSatellites();     
//获取第一次定位时间（启动到第一次定位）    
int costTime=gpsStatus.getTimeToFirstFix();   
//获取卫星    
Iterable<GpsSatellite> iterable=gpsStatus.getSatellites();   
//一般再次转换成Iterator    
Iterator<GpsSatellite> itrator=iterable.iterator();
#+end_src
**** GpsSatellite
GpsSatellite，定位卫星，包含卫星的方位、高度、伪随机噪声码、信噪比等信息
#+begin_src java
//获取卫星    
Iterable<GpsSatellite> iterable=gpsStatus.getSatellites();   
//再次转换成Iterator    
Iterator<GpsSatellite> itrator=iterable.iterator();   
//通过遍历重新整理为ArrayList    
ArrayList<GpsSatellite> satelliteList=new ArrayList<GpsSatellite>();    
int count=0;   
int maxSatellites=gpsStatus.getMaxSatellites();   
while (itrator.hasNext() && count <= maxSatellites) {     
    GpsSatellite satellite = itrator.next();     
    satelliteList.add(satellite);     
    count++;   
}    
System.out.println("总共搜索到"+count+"颗卫星");   
//输出卫星信息    
for(int i=0;i<satelliteList.size();i++){   
    //卫星的方位角，浮点型数据    
    System.out.println(satelliteList.get(i).getAzimuth());   
    //卫星的高度，浮点型数据    
    System.out.println(satelliteList.get(i).getElevation());   
    //卫星的伪随机噪声码，整形数据    
    System.out.println(satelliteList.get(i).getPrn());   
    //卫星的信噪比，浮点型数据    
    System.out.println(satelliteList.get(i).getSnr());   
    //卫星是否有年历表，布尔型数据    
    System.out.println(satelliteList.get(i).hasAlmanac());   
    //卫星是否有星历表，布尔型数据    
    System.out.println(satelliteList.get(i).hasEphemeris());   
    //卫星是否被用于近期的GPS修正计算    
    System.out.println(satelliteList.get(i).hasAlmanac());   
}
#+end_src
** jni
JNI是java native interface的缩写
* FreeRTOS
FreeRTOS是一个迷你操作系统内核的小型嵌入式系统。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、
内存管理、记录功能等，可基本满足较小系统的需要。 功能和特点:
- 混合配置选项;
- 提供一个高层次的信任代码的完整性;
- 目的是小，简单易用;
- 以开发C，非常便携代码结构;
- 支持两项任务和共同例程;
- 强大的执行跟踪功能;
- 堆栈溢出检测 ;
- 没有软件任务的限制数量;
- 没有软件优先事项的限制数量;
- 没有施加的限制，优先转让，多个任务可以分配相同的优先权;
- 队列，二进制信号量，计数信号灯和递归通信和同步的任务 ;
- Mutexes优先继承权;
- 免费开发工具;
- 免费嵌入式软件的源代码;
- 从一个标准的Windows主机交叉发展;
** 术语
- PV操作：P源自于荷兰语parsseren，即英语的pass；V源自于荷兰语verhoog，即英语的increment。P(S)V(S)操作是信号量的两个原子
  操作，S为信号量semaphore，相当于一个标志，可以代表一个资源，一个事件等；
- 变量的非原子操作：更新结构体的多个成员变量，或者是更新的变量其长度超过了架构体系的自然长度(比如，更新一个16位机上的32
  位变量)均是非原子操作，如果这样的操作被中断，将可能导致数据损坏或者丢失；
- 函数重入：如果一个函数可以安全的被多个任务调用，或在任务与中断中均可调用，则这个函数是可以重入的；一般每个任务都单独维
  护自己的栈空间及其自身在内存寄存器组中的值。如果一个函数除访问自己栈空间上分配的数据或是内核寄存器中的数据外，会访问其
  他任何数据，则这个函数是不可重入的。
- 临界区：当某资源需要被多个任务访问使用时，此资源叫临界区，开始访问此资源，表示进入临界区；如果要进入临界区，一般安全的
  做饭是讲所有的中断或者优先级关闭，防止在访问临界区资源时，被打断，并且访问临界区资源的程序必须要尽快结束；
- 二值信号量：用于同步，可以给某资源配置一个二值信号量，当一个任务要访问某资源时，如果此二值信号量不可用，则该任务不可访
  问该资源，可以通过在中断中给予(GIVE)此信号量，则此任务就可以获得(TAKE)该信号量，访问该资源，达到同步作用，用于同步的信
  号量，用完后便丢弃，不再归还；
- 互斥信号量：用于访问一些具有互斥效果的资源，类似二值信号量，当某任务需要访问某资源时，需要先获得(TAKE)该资源的令牌(信
  号量)，用完后，再归还(GIVE)该资源的令牌，一个任务只有获得了该资源的令牌后才能访问该资源，否则不允许访问进入阻塞状态，
  用于互斥的信号量必须归还；
- 优先级翻转：指两个不同优先级的任务在允许时，低优先级的任务获得了某资源的互斥信号量，并未执行完，此时高优先级的任务也开
  始运行，并且也要使用该资源，从而获取该资源的互斥信号量，然后此时低优先级的任务并未释放该互斥信号量，则高优先级的任务进
  入阻塞状态，等待低优先级的任务执行完释放信号量，从而产生了高优先级的任务等待低优先级任务的不合理现象；
- 死锁：当两个任务都在等待被对方持有的资源时，两个任务都无法继续执行，这种情况被称为死锁；
- 守护任务：守护任务提供了一个比较好的方法来实现互斥功能，而不用担心会发生优先级翻转和死锁，守护任务是对某个资源具有唯一
  所有权的任务，只有守护任务才可以直接访问其守护的资源，其他任何任务只能间接的通过守护任务提供访问服务；
** 源码解读
*** 文件
**** FreeRTOS.h
每一个使用了FreeRTOS的程序都需要包含的一个头文件；
**** projdefs.h
包含了FreeRTOS的一些基本设定，主要定义了如下一些宏定义
#+begin_src c
    pdTASK_CODE   //任务函数原型类型
    pdFALSE
    pdTRUE
    pdPASS
    pdFAIL
    errQUEUE_EMPTY
    errQUEUE_FULL
    errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
    errNO_TASK_TO_RUN
    errQUEUE_BLOCKED
    errQUEUE_YIELD
#+end_src
**** FreeRTOSConfig.h
移植的时候要修改的FreeRTOS的全局配置文件; 
**** portable.h
*** 功能函数
**** 任务生成
任务生成使用xTaskGenericCreate函数，并且被宏包装为xTaskCreate；
**** 任务删除
**** 堆操作
堆并不神秘，在cortex-m0芯片中，堆和栈其实都是用的ram区，只是认为的堆ram区做了划分，也就是说，完全可以人为的定义一个大的
数组来表示堆空间，然后对数组进行块分割，并且分配给申请者，管理需要释放的数组元素，就是堆空间的分配和释放操作，基于此，根
据堆操作功能复杂度，细化出了heap_1.c、heap_2.c、heap_4.c、heap_5.c的堆操作功能库，至于heap_3.c完全是使用标准C库的malloc
等函数做的封装，因为标准C库的malloc等函数不是线程安全的函数，需要封装为安全的，所谓的封装为线程安全的，也就是在执行
malloc前后关闭打开中断和调度器；另外对申请的堆空间地址和长度还涉及到对齐等细节功能操作；
# <<heap1-oper>>
- heap\_1.c: 只有简单的堆空间申请操作，没有释放操作；
  #+begin_src c
    /* portBYTE_ALIGNMENT:这个常量指示字节对齐数，其默认值为8，即默认以8个字节进行内存对齐 */
    /* portBYTE_ALIGNMENT_MASK:这个常量是根据portBYTE_ALIGNMENT的值进行定义的 */
    /* FreeRTOS对堆数组进行地址对齐操作，这样的后果就是要是原本堆数组首地址没有对齐，
     * 则进行对齐操作后就会使堆大小改变了。因此，FreeRTOS对堆数组的大小进行重新定义。 
     */
#define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
/**
 * 数组的总大小(字节为单位)在FreeRTOSConfig.h中由configTOTAL_HEAP_SIZE定义。
 * 以这种方式定义一个巨型数组会让整个应用程序看起来耗费了许多内存
 * ucHeap就是FreeRTOS可以用的整个堆的空间数组，其大小是在FreeRTOSConfig.h中定义的常量configTOTAL_HEAP_SIZE，
 * 默认是17*1024，即17KB
 */
static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
///指向下一个还没被用上的内存堆所在的数组下标，由于一开始整个堆都没被用上，所以它的默认值为0
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/
/** 
 * @brief 这种分配方案是将 FreeRTOS 的内存堆空间看作一个简单的数组。
 * 当调用pvPortMalloc()时，则将数组又简单地细分为更小的内存块。函数操作流程
 * 第一步：对齐处理；第二步：分配内存；第三步：勾子函数调用。
 * @param xWantedSize 欲分配的空间大小
 */
void *pvPortMalloc( size_t xWantedSize )
{
    void *pvReturn = NULL;
    static uint8_t *pucAlignedHeap = NULL;
    /* **************************************第一步********************************* */
    /** 用来判断用户所需要的内存大小是否已对齐，例如，在默认情况下（以8个字节对齐），
     * 如果用户申请的内存大小为13个字节，经过和字节对齐掩码进行与操作后的结果为0x0005，即没有对齐；
     * 如果用户申请的内存大小为16个字节，经过和字节对齐掩码进行与操作后的结果为0x0000，即已经对齐。 
     */
	#if portBYTE_ALIGNMENT != 1 
    if( xWantedSize & portBYTE_ALIGNMENT_MASK )
    {
        /** 用户申请内存大小和字节对齐掩码进行与操作后，其结果和需要补齐的字节数相加，
         * 刚好等于字节对齐掩码的值，因此只要用掩码值减去与操作的结果，就可以得到需要补齐的字节数，
         * 这样只要把补齐的字节数加到用户申请的内存大小就可以使其字节对齐 
         */
        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    }
	#endif

    /* **************************************第二步********************************* */
	vTaskSuspendAll();
	{
        /** 对这个堆进行对齐工作。这里的对齐和上面说的对齐不是一回事。
         * 这里说的对齐是因为FreeRTOS管理的堆是一个全局数组，
         * 并不能保证数组首地址按portBYTE_ALIGNMENT对齐。
         * 因此FreeRTOS对堆首地址做了这个对齐处理。要留意的是，这个对齐处理只做了一次。
         * 原因是对齐后的堆首地址是一个静态变量，初始值赋为NULL。
         * 而当这个变量为NULL时才进行对齐处理，对齐处理后这个变量就指向堆首地址，
         * 这样在下一次调用pvPortMalloc()时就不会再进行对齐处理了 
         */
		if( pucAlignedHeap == NULL ) /* 第一次初始化heap */
		{
            /* ucHeap往前挪动一个portBYTE_ALIGNMENT长度的地址，做对齐后，才能保证对齐后的地址还在ucHeap数组范围内 */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) &
                                             ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
            /* 记录新分配空间的首地址到pvReturn */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
        /** 用于输出内存分配的调试信息，这个宏定义在FreeRTOS.h中，默认为空，
         * 如果需要将这些调试信息输出到串口或其它东西，就可以修改这个宏将信息输出到所需要的地方。 
         */
		traceMALLOC( pvReturn, xWantedSize ); 
	}
	( void ) xTaskResumeAll();

    /** 当内存分配失败的时候，如果在FreeRTOS.h中有定义宏configUSE_MALLOC_FAILED_HOOK=1，
     * 则会调用一个勾子函数vApplicationMallocFailedHook()。在这个勾子函数中，
     * 用户可以进行其它一些必要的操作 
     */
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook(); 
		}
	}
	#endif
	return pvReturn;
    }
  #+end_src
# <<heap2-oper>>
- heap\_2.c: 同[[heap1-oper][heap\_1.c]]差不多，只是采用一定算法来分配空间，增加了堆释放操作, ；
#+begin_src c
void vPortFree( void *pv )
{
    uint8_t *puc = ( uint8_t * ) pv;
    BlockLink_t *pxLink;
	if( pv != NULL )
	{
        /* 寻找这个内存空间的空闲块头 */
		before it. */
		puc -= heapSTRUCT_SIZE;
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
		{
            /* 插入空闲块链表中 */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
            /* 修正剩余空间大小 */
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
#+end_src
- heap\_3.c: 对C标准库的堆操作函数做了线程安全的封装; 
分配函数：
#+begin_src c
void *pvPortMalloc( size_t xWantedSize )
{
    void *pvReturn;
	vTaskSuspendAll();
	{
		pvReturn = malloc( xWantedSize );
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
		}
	}
	#endif
	return pvReturn;
}
#+end_src
释放函数：
#+begin_src c
void vPortFree( void *pv )
{
	if( pv )
	{
		vTaskSuspendAll();
		{
			free( pv );
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
	}
}
#+end_src
- heap\_4.c: 同[[heap2-oper][heap\_2.c]]差不多，只是分配算法做了更优化，并且相邻空闲空间可以合并；
#+begin_src c
void *pvPortMalloc( size_t xWantedSize )
{
    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
    void *pvReturn = NULL;

	vTaskSuspendAll();
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
		{
			prvHeapInit();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

        /**
         * 判断用户申请内存大小的最高位是否为0，为0即合法
         * （之前说过，最高位用来标识空闲块的空闲状态，因此最高位为1则说明用户申请的内存大小已超出空闲块的最大大小）
         */
		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
			{
				xWantedSize += xHeapStructSize; /* 增加block头大小 */

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) /* 对齐操作 */
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
                /**
                 * 首先遍历链表，找到第1块能比申请空间大小大的空闲块，修改空闲块的信息，
                 * 记录用户可用的内存首地址。接下来，如果分配出去的空闲块比申请的空间大很多，
                 * 则将该空闲块进行分割，把剩余的部分重新添加到链表中。
                 */
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize ); /* 获得真正申请的空间地址 */

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock; /* 空闲block链接起来 */

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) /* 见heap_2.c */
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
						pxBlock->xBlockSize = xWantedSize;

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
					pxBlock->pxNextFreeBlock = NULL;
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
#+end_src
**** 杂项功能
这些杂项功能大部分都跟平台有关，这里以cortex M系列为例；
- 参数断言：使用宏configASSERT, 是空的，需要用户自己写
- 提升优先级：static BaseType_t prvRaisePrivilege( void )，通过控制cpu做svc调用，svc有相应的号；



