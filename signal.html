<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>信号与系统</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="信号与系统"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2016-05-25 00:02:27 中国标准时间"/>
<meta name="author" content="比克曼"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<link rel='stylesheet' type='text/css' href='css/org-manual.css' />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">信号与系统</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 线性时不变系统</a>
<ul>
<li><a href="#sec-1-1">1.1 卷积</a></li>
<li><a href="#sec-1-2">1.2 傅里叶级数和泰勒级数</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1 泰勒级数</a></li>
<li><a href="#sec-1-2-2">1.2.2 傅里叶级数</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3 离散时间傅里叶变换(DTFT)</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 DTFT算法过程</a></li>
<li><a href="#sec-1-3-2">1.3.2 物理意义</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4 离散傅里叶变换(DFT)</a></li>
<li><a href="#sec-1-5">1.5 滤波器</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1 设计思路</a></li>
<li><a href="#sec-1-5-2">1.5.2 FIR滤波</a></li>
<li><a href="#sec-1-5-3">1.5.3 IIR滤波</a></li>
<li><a href="#sec-1-5-4">1.5.4 平滑滤波</a>
<ul>
<li><a href="#sec-1-5-4-1">1.5.4.1 全期平滑</a></li>
<li><a href="#sec-1-5-4-2">1.5.4.2 移动平滑</a></li>
<li><a href="#sec-1-5-4-3">1.5.4.3 指数平滑</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6 采样重构</a>
<ul>
<li><a href="#sec-1-6-1">1.6.1 频率</a></li>
<li><a href="#sec-1-6-2">1.6.2 采样</a></li>
<li><a href="#sec-1-6-3">1.6.3 重构</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-2">2 小波变换</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 线性时不变系统</h2>
<div class="outline-text-2" id="text-1">

<p>线性时不变系统简称LTI系统，可以用它对单位脉冲序列的响应(h(n))来表示。
</p><ul>
<li>离散信号可以由单位冲击响应信号来表示。式子如<a href="#equ-sigma">equ-sigma</a>, 其中x[k]可以
  看做常量，\(\sigma[n]\) 是冲激响应。
  \begin{equation}
  \label{equ-sigma}
   x[n]=\sum_{k=-\infty}^{+\infty}x[k]\sigma[n-k]
  \end{equation}
</li>
<li>傅里叶变化和级数：如果x(t)有一个傅里叶级数表示式<a href="#equ-xt">equ-xt</a>，即x(t)能够
  表示成一组谐波关系的复指数信号的线性组合，那么傅里叶级数中的系数a<sub>k</sub>确定，
  这对关系式就定义为一个周期连续时间信号的傅里叶级数, 其中周期为T，
  \(w_{0}=\frac{2\pi}{T}\) 
  \begin{equation}
  \label{equ-xt}
   x(t)=\sum_{-\infty{}}^{+\infty{}}a_{k}e^{jkw_{0}t}
  \end{equation}
  系数为式<a href="#equ-ak">equ-ak</a>
  \begin{equation}
  \label{equ-ak}
   a_{k}=\frac{\int_{T}x(t)e^{-jkw_{0}t}\mathrm{d}t}{T}
  \end{equation}
</li>
<li>频率响应：一个脉冲响应(h(n))的离散时间傅里叶变换称为一个LTI系统的频率响应
  或传递函数.也可以理解为，脉冲响应h(n)对某频率输入信号的响应，输入信号x(n)
  可以表示成\(e^{jwn}\)的级数形式，也代表了x(n)具有一系列频率分量w，求一个
  系统对复指数信号\(e^{jw_{0}n}\)的响应时，输入信号为\(x(n)=e^{jw_{0}n}\),
  该响应由式子<a href="#equ-ejwnhn">equ-ejwnhn</a>
  \begin{equation}
  \label{equ-ejwnhn}
  x(n)=e^{jw_{0}n} \Rightarrow h(n) \Rightarrow y(n)=h(n)*e^{jw_{0}n}
  \end{equation}
  因而
  \begin{equation}
  \label{equ-whn}
  y(n)=h(n)*e^{jw_{0}n}=\sum_{k=-\infty}^{\infty}h(k)e^{jw_{0}(n-k)}
      = [\sum_{k=-\infty}^{\infty}h(k)e^{-jw_{0}k}]e^{jw_{0}n} 
      = [F[h(n)]|_{w=w_{0}}]e^{jw_{0}n}
  \end{equation}
  由于输入信号x(n)可以表示成复指数的级数形式，所以x(n)的每个频率分量都可以
  经过h(n)在每个频率上做响应，进而叠加得到x(n)的输出y(n)，式子<a href="#equ-whn">equ-whn</a>
  也说明了输出序列是输入指数序列被系统h(n)在w<sub>0</sub>频率处的响应修饰后的结果。
  因此一个LTI系统可以在频域表示为式子<a href="#equ-frqzone">equ-frqzone</a>, 时域y(n)可从
  \(Y(e^{jw})\)用傅里叶逆变换获得。 
  \begin{equation}
  \label{equ-frqzone}
  X(e^{jw}) \Rightarrow H(e^{jw}) \Rightarrow Y(e^{jw})=H(e^{jw})X(e^{jw})
  \end{equation}
</li>
<li>傅里叶级数，傅里叶变换，拉普拉斯变换，Z变换： <span style="text-decoration:underline;">傅里叶级数</span> 只能对周期信号
  进行分析，找出主要频率分量，也就是相应频率信号幅度最大(能量越大)的信号；
  傅里叶级数具有周期性的局限性，所以又有了 <span style="text-decoration:underline;">傅里叶变换</span> ，此时信号不必是周
  期性的，但是也有条件，那就是必须要是能量有限，也就是绝对可积。所以傅里叶
  变换用于处理非周期信号；然而也有局限性，不适用于指数级增长的信号，所以又
  推出了 <span style="text-decoration:underline;">拉普拉斯变换</span> ，拉氏变换相当于是带有一个指数收敛因子的傅里叶变换，
  把频域推广到复频域，能够分析的信号就更广了，傅立叶变换是拉普拉斯变换的一
  种特例，在拉普拉斯变换中，只要令Re[s]=1,就得到傅立叶变换 ，然而缺点是从拉
  氏变换中只能看到复变量s，没有频率f的概念，要看幅频响应和相频响应，需要令 
  \(s=j2\pi{}f\). <span style="text-decoration:underline;">Z变换</span> 简单地说，就是离散信号(也可以叫做序列)的拉普拉斯
  变换，也可以说是离散时间信号的傅里叶变换，如果说拉氏变换专门分析模拟信号，
  那Z变换就是专门分析数字信号，Z变换可以把离散卷积变成多项式乘法，Z变换看系
  统频率响应。
</li>
</ul>


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 卷积</h3>
<div class="outline-text-3" id="text-1-1">

<p>如果一个系统的冲击响应为h(n), 表示方式如<a href="#equ-hn">equ-hn</a>，可以理解为由于一个k时
刻的单位脉冲\(\sigma{}(n-k)\)引起的系统响应为h(n-k), 而输入信号x(n)是由k从
负无穷时刻到正无穷时刻的所有冲击\(\sigma{}(n-k)\)叠加，所以x(n)的对于线性系
统的响应也就由从负无穷到正无穷逐个移位出来的h(n-k)叠加而成，写成卷积形式如
<a href="#equ-conv">equ-conv</a>, 从某种意义上讲，卷积的输出结果是和时间没有关系的，所以一般
MATLAB或者python的卷积计算函数都不用带时间信息，只需要输入值序列。
\begin{equation}
\label{equ-hn}
 \sigma{}(n-k) \Rightarrow h(n-k)
\end{equation}
\begin{equation}
\label{equ-conv}
 y(n) = x(n)*h(n) 
\end{equation}
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 傅里叶级数和泰勒级数</h3>
<div class="outline-text-3" id="text-1-2">

<p>傅里叶级数和泰勒级数都是为了将一个函数分解成若干基函数叠加形式。
</p>
</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 泰勒级数</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>一个函数
$$f(x)=1$$ 
它的泰勒展开式是
$$f(x)=1$$ 
函数
$$f(x)=x$$ 
它的泰勒展开式是
$$f(x)=x$$ 
也就是泰勒展开将函数分解成\(1, x, x^{2}, x^{3}...\)等幂级数的和，也就是将一
个函数变成若干个函数的和。展开式在多数情况下有无限项。泰勒展开式见式
<a href="#equ-taile">equ-taile</a>
\begin{equation}
\label{equ-taile}
f(x)=\sum_{n=0}^{\infty}\frac{f^{(n)}(x_{0})}{n!}(x-x_{0})^{n}
    = f(x_{0})+f^{'}(x_{0})(x-x_{0})+\frac{f^{''}(x_{0})}{2!}(x-x_{0})^{2}...
\end{equation}
那么为什么要将f展开成泰勒级数\(f(x)=1+x+x^{2}+x^{3}+...\)，那是因为可以无限细
分得到f在每个点的变化。这类似将3234.352拆分成3000+200+30+4+0.3+0.05+0.002一
样。所谓对函数的无限细分，就是不断求导，得到若干个变化率，从而得到这个函数
到底在各个点变化的有多剧烈。变化就是导数。泰勒级数的每一阶系数就是各阶导数。
所以泰勒级数就是在描述一个函数的各个点的变化情况。
</p></div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 傅里叶级数</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>傅里叶级数也叫三角级数一般为
$$f(x)=1+sin(x)+cos(x)+sin(2x)+cos(2x)+... $$ 
只有周期函数才有傅里叶级数，非周期函数由傅里叶变换来处理。一个方波信号可以
表示成多个不同频率的正弦波组成。在某种程度上也可以认为方波是各种信号的基，
基于这样的认识有人提出了沃尔什变换。将函数分解成三角函数的和很重要。因为对
于一个周期函数来说，和周期对应的是频率。频率表示周期性变化的快慢。频率可以
表征非常广泛的一类属性。在电子学里，有电容隔直通交。其实这就是电容对电学量，
比如电压和电流，不同频率特性的不同体现。对于频率为0 的电压，被隔断，对于频
率为w的电压，会产生与w 和电压U成正比的电流。所以讲一个信号函数分解成不同频
率的分量就比较好处理问题。那为什么分解时最好用正余弦的频率，因为正余弦函数
是二阶偏微分方程(含有电容或电感等的电路方程)的本征解。另外，世界上只有两类
函数能满足给自己求二阶导还是这类函数本身，仅相差常数系数和正负号，一种就是 
\(e^{x}\)，另一种就是\(sin(x), cos(x)\), 后来又在复数域里统一了这两者即
$$e^{jx}=cos(x)+sin(x)j$$ 
所以，对于一个一般的物理信号来说，它可能不是正余弦函数，但是他们都可以拆成
不同频率的三角函数的组合。重要的是对于某种单频率的三角函数信号，系统对该频
率的三角函数的输入的响应还是同频率的三角函数，只可能有相位前后或者幅度大小
发生变化。这样就是二阶偏微分方程的本征解的含义。</p ><p >
我们知道我们要把信号函数展开成三角不同频率的三角函数的和，且系统对某种频率
的三角函数的响应方式还是同频率的三角函数，所以响应也是对这些不同频率三角函
数响应的叠加，这也叫频域分析。傅里叶级数的三角表示公式如<a href="#equ-flysj">equ-flysj</a>
\begin{equation}
\label{equ-flysj}
f(x)=a_{0}+\sum_{n=l}^{\infty}(a_{n}cos\frac{n\pi x}{l}+b_{n}sin\frac{n\pi x}{l})
\end{equation}
用这个式子可以表示周期是\(2l\)的周期函数，之所以所有频率都是基频的倍数，是
因为它要符合周期性边界条件。式<a href="#equ-flysj">equ-flysj</a>可以简化为式子<a href="#equ-flysjj">equ-flysjj</a>
\begin{equation}
\label{equ-flysjj}
f(x)=a_{0}+A_{1}sin(w_{1}x+phi_{1})+A_{2}sin(2w_{2}x+phi_{2})+...
\end{equation} 
式子<a href="#equ-flysjj">equ-flysjj</a>可以把傅里叶级数理解成，把周期函数拆成常数(直流分量)+一
倍频分量+2倍频分量+&hellip;
其系数\(A_{k}\)需要通过函数投影计算。函数投影类似向量的投影，一个函数u和一
个函数v的投影计算方式如<a href="#equ-fun-dot">equ-fun-dot</a>, 也就是u和v的内积就是他们相乘，并
在全区间上积分。
\begin{equation}
\label{equ-fun-dot}
 (u, v) = \int_{a}^{b}u(x)\hat{v}(x)dx
\end{equation}
而在周期函数里面区间端点[a, b]就是任何一个长度为\(2\pi\)的区间端点。那么如
果把u表示成f(x)，v分别取\(1, sin(x), cos(x), sin(2x)...\)等，就可以得到每
个频率的各自部分的分量大小(因为有积分累加)。为什么就一定能够筛选出对应频率
的所以分量来累加呢，这是因为有完备单位正交基，所谓的完备，就是指用
\(1, sin(x), cos(x), sin(2x)...\)完全能够把一个函数f(x)表示出来。
所谓正交，如式子<a href="#equ-zj">equ-zj</a>两两相乘区间累加都等于0，是正交的。
\begin{equation}
\label{equ-zj}
\int_{0}^{2\pi}1*sin(x)dx=0, 
\int_{0}^{2\pi}sin(mx)*cos(nx)dx=0, 
\int_{0}^{2\pi}sin(mx)*sin(nx)dx=0, 
\end{equation}
所谓单位，就是还需要归一化，比如<a href="#equ-notuni">equ-notuni</a>不是归一化的。
\begin{equation}
\label{equ-notuni}
\int_{0}^{2\pi}1*1dx=2\pi
\int_{0}^{2\pi}sin(kx)*sin(kx)dx=pi
\end{equation}
要归一化就得变成如下式子
\begin{equation}
\int_{0}^{2\pi}\frac{1}{\sqrt{2\pi}}*\frac{1}{\sqrt{2\pi}}dx=1
\int_{0}^{2\pi}\frac{1}{\sqrt{\pi}}sin(kx)*\frac{1}{\sqrt{\pi}}sin(kx)dx=1
\end{equation}
所以傅里叶分解真正的基底是这些, 对于周期为\(2\pi\)
$$\frac{1}{\sqrt{2\pi}},\frac{1}{\sqrt{\pi}}sin(x),\frac{1}{\sqrt{\pi}}cos(x)...$$ 
对于周期为\(2l\)的，基底是
$$\frac{1}{\sqrt{2l}},\frac{1}{\sqrt{l}}sin(x),\frac{1}{\sqrt{l}}cos(x)...$$
综合来看，用内积方法分解出的每个分量的系数如式子<a href="#equ-neijfly">equ-neijfly</a>, 如果是非
单位化的基，结果就没有这么简洁。
\begin{equation}
\label{equ-neijfly}
a_{0} = \frac{\int_{-l}^{l}f(x)dx}{2l}
a_{n} = \frac{\int_{-l}^{l}f(x)cos(\frac{n\pi x}{l})dx}{l}
b_{n} = \frac{\int_{-l}^{l}f(x)sin(\frac{n\pi x}{l})dx}{l}
\end{equation}
</p></div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 离散时间傅里叶变换(DTFT)</h3>
<div class="outline-text-3" id="text-1-3">

<p>如果x(n)是绝对可加的，即\(\sum_{-\infty}^{\infty}|x(n)| &lt; \infty\)，则其离
散时间傅里叶变换表示如<a href="#equ-xjw">equ-xjw</a>
\begin{equation}
\label{equ-xjw}
 X(e^{jw}) \Rightarrow F[x(n)]=\sum_{-\infty}^{\infty}x(n)e^{-jwn}
\end{equation}
\(X(e^{jw})\)的离散时间傅里叶逆变换(IDTFT)可以表示如[[#equ-xn][equ-xn]]
\begin{equation}
\label{equ-xn}
 x(n) \Rightarrow F^{-1}[X(e^{jw})]=\frac{1}{2\pi}\int_{-\pi}^{\pi}X(e^{jw})e^{jwn}dw
\end{equation}
算子F[.]把一个离散信号x(n)变换成一个实变量w的复值连续函数\(X(e^{jw})\), w被
称为数字频率，它用 <span style="text-decoration:underline;">弧度</span> 来度量。
基本上离散和周期是相互关联的。
</p><ul>
<li>时域离散，频域就会有周期性；
</li>
<li>频域离散，时域就会有周期性；
</li>
</ul>


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> DTFT算法过程</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>如果x(n)是有限长的，则x(n)肯定是绝对可加的，即x(n)肯定有DTFT，则可以用
MATLAB或python来对任意频率w处的\(X(e^{jw})\)进行数值计算。如果我们是在
\([0, \pi]\)间等间隔频率点来模拟估计\(X(e^{jw})\)，假设分成M分，则每个频率
点可以表示如公式<a href="#equ-wk">equ-wk</a>所示，则变换式子<a href="#equ-xjw">equ-xjw</a>可以用矩阵向量相乘
的运算来实现。
\begin{equation}
\label{equ-wk}
w_{k} \Rightarrow \frac{\pi}{M}k, (k = 0, 1, ...,M)
\end{equation}
假定序列x(n)在\(n_{1}&lt;= n &lt;=n_{n}\)有N个样本，要估计点<a href="#equ-wk">equ-wk</a>上的
\(X(e^{jw})\)值。它们是[0，&pi;]之间的(M+1)个等间隔频率点，则<a href="#equ-xjw">equ-xjw</a>可
以写为式子<a href="#equ-xjw2">equ-xjw2</a>
\begin{equation}
\label{equ-xjw2}
 X(e^{jw_{k}})=\sum_{l=1}^{N}e^{-j(\pi/M)kn_{l}}*x(n_{l}), (k=0, 1, ..., M)
\end{equation}
当\({x(n_{l})}\)和\({X(e^{jw_{k}})}\)分别排成列向量x和X，我们有式子
<a href="#equ-vec">equ-vec</a>, 其中W是一个(M+1)乘N维矩阵
\begin{equation}
\label{equ-vec}
 X = Wx
\end{equation}
另外，若我们分别将{k}和{n<sub>l</sub>}排成列向量，则有式子<a href="#equ-wvec">equ-wvec</a>
\begin{equation}
\label{equ-wvec}
 W = [e^{-j\frac{\pi}{M}k^{T}n}]
\end{equation}
最终可以写成式子<a href="#equ-fvec">equ-fvec</a>, 如果x是行行向量，则x<sup>T</sup>直接就用x表示。
\begin{equation}
\label{equ-fvec}
 X^{T} = x^{T}[e^{-j\frac{\pi}{M}n^{T}k}]
\end{equation}
</p></div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 物理意义</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>DFT的快速算法叫FFT，在MATLAB和Python中都有相关库，一个模拟信号，经过ADC采样
之后，就变成了数字信号。采样定理告诉我们，采样频率要大于信号频率的两倍，采
样得到的数字信号，就可以做FFT变换了。N个采样点，经过FFT之后，就可以得到N个
点的FFT结果。为了方便进行FFT运算，通常N取2的整数次方。假设采样频率为Fs，信
号频率F，采样点数为N。那么FFT之后结果就是一个为N点的复数。每一个点就对应着
一个频率点。这个点的模值，就是该频率值下的幅度特性。具体跟原始信号的幅度有
什么关系呢？假设原始信号的峰值为A，那么FFT的结果的每个点（除了第一个点直流分量之外）的模值就是A的N/2倍。而第一个点就是直流分量，它的模值就是直流分量
的N倍。而每个点的相位呢，就是在该频率下的信号的相位。第一个点表示直流分量
（即0Hz），而最后一个点N的再下一个点（实际上这个点是不存在的，这里是假设的
第N+1个点，也可以看做是将第一个点分做两半分，另一半移到最后）则表示采样频率
Fs，这中间被N-1个点平均分成N等份，每个点的频率依次增加。例如某点n所表示的频
率为
$$Fn=(n-1)*Fs/N$$
由上面的公式可以看出，Fn所能分辨到频率为为Fs/N，如果采样频率Fs为1024Hz，采
样点数为1024点，则可以分辨到1Hz。1024Hz的采样率采样1024点，刚好是1秒，也就
是说，采样1秒时间的信号并做FFT，则结果可以分析到1Hz，如果采样2秒时间的信号
并做FFT，则结果可以分析到0.5Hz。如果要提高频率分辨力，则必须增加采样点数，
也即采样时间。频率分辨率和采样时间是倒数关系。 </p ><p >
假设FFT之后某点n用复数a+bi表示，那么这个复数的模就是
$$An=\sqrt{a^{2}+b^{2}}$$ 
相位就是
$$Pn=atan2(b,a)$$
根据以上的结果，就可以计算出n点（n≠1，且n&lt;=N/2）对应的信号的表达式为：
$$An/(N/2)*cos(2*pi*Fn*t+Pn)$$ 
即\(2*An/N*cos(2*pi*Fn*t+Pn)\)。对于n=1点的信号，是直流分量，幅度即为A1/N。
由于FFT的对称性，通常我们只使用前半部的结果，即小于采样频率一半的结果.</p ><p >
总结：假设采样频率为Fs，采样点数为N，做FFT之后，某一点n（n从1开始）表示的频
率为：Fn=(n-1)*Fs/N；该点的模值除以N/2就是对应该频率下的信号的幅度（对于直
流信号是除以N）；该点的相位即是对应该频率下的信号的相位。相位的计算可用函数
atan2(b,a)计算。atan2(b,a)是求坐标为(a,b)点的角度值，范围从-pi到pi。要精确
到xHz，则需要采样长度为1/x秒的信号，并做FFT。要提高频率分辨率，就需要增加采
样点数，这在一些实际的应用中是不现实的，需要在较短的时间内完成分析。解决这
个问题的方法有频率细分法，比较简单的方法是采样比较短时间的信号，然后在后面
补充一定数量的0，使其长度达到需要的点数，再做FFT，这在一定程度上能够提高频
率分辨力。 
</p></div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 离散傅里叶变换(DFT)</h3>
<div class="outline-text-3" id="text-1-4">

<p>离散时间傅里叶变换（DTFT）有时也称为序列傅里叶变换。DTFT实质上就是单位圆上
的(双边)Z变换。当时域信号为连续信号时，用连续时间傅里叶变换；为离散信号时，
用DTFT,DTFT使我们能够在频域（数字频域）分析离散时间信号的频谱和离散系统的频
响特性\(X(e^{jw})\)。但还存在两个实际问题。 
</p><ol>
<li>数字频率w是一个模拟量，为了便于用数字的方法进行分析和处理，仅仅在时域将
   时间变量t离散化还不够，还必须在频域将数字频率w离散化。 
</li>
<li>实际的序列大多为无限长的，为了分析和处理的方便，必须把无限长序列截断或分
   段，化作有限长序列来处理。 
</li>
</ol>

<p>DTFT是对任意序列的傅里叶分析，它的频谱是一个连续函数；而DFT是把有限长序列作
为周期序列的一个周期，对有限长序列的傅里叶分析，DFT的特点是无论在时域还是频
域都是有限长序列。DFT提供了使用计算机来分析信号和系统的一种方法，尤其是DFT
的快速算法FFT。 
</p><ul>
<li>np.fft.fft(samplings):对samplings点做FFT变换；
</li>
<li>np.fft.rfft(samplings):上面的是左右两边对称的，这个是只有单边的；
</li>
<li>np.fft.fftfreq(N):表示N点的频率序号，如果再乘以频率分辨率Fs/N, 就可以得到
  N点的频率值；
</li>
<li>fft变换后，除第一个0频直流分量，频谱在频率上对称，对称点在奈奎斯特频率上，
  即如果Fs是采样频率，对称点在Fs/2上；
</li>
<li>当时域数据个数和fft变换使用的数据个数相同时，频率分辨率正常(点数较少时，
  分辨率低)，但是没有由于添零混入其他频率成分；
</li>
<li>当时域信号数据加零数据后，可以增加fft变换的数据个数，可以提高频率分辨率，
  但是振幅谱中会多出其他频率成分；
</li>
</ul>

</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 滤波器</h3>
<div class="outline-text-3" id="text-1-5">

<p>数字滤波器与LTI系统是等价的，描述方式可以有4种。
</p><ul>
<li>差分方程；
</li>
<li>单位冲激响应h(n), 可以分类如下；
<ol>
<li>FIR滤波器：有限脉冲响应，也就是h(n)只在一段时间内才有信号，其他都是0。
</li>
<li>IIR滤波器：无限脉冲响应，也就是h(n)在所有时间内都有信号。
</li>
</ol>

</li>
<li>传递函数:若用X(z)表示输入x(n)的Z变换，用Y(z)表示输出y(n)的Z变换，则滤波
   器的传递函数可以写为：
   $$H(z)=\frac{Y(z)}{X(z)}=\frac{b_{0}+b_{1}z^{-1}+..+b_{N-1}z^{-(N-1)}}{1+a_{1}z^{-1}+..+a_{M-1}z^{-(M-1)}}$$  
   利用该式可以用零极图和矢量等工具对滤波器进行直观的分析。通常M&gt;=N, 对FIR
   滤波器来说H(z)的零点个数为滤波器的阶数。对IIR滤波器来说，H(z)的极点个数
   称为滤波器的阶数。所以FIR滤波器的阶数为N-1，IIR滤波器的阶数为M-1。阶数越
   高表明滤波器的系数越多，在实现时运算效率也越低。
</li>
<li>频率响应：复指数信号是LTI系统的特征信号，也是滤波器的特征信号，当滤波器输
  入为单频复指数信号时，系统的输出为频率相同的单频正弦信号，只是幅度和相位
  可能发生改变。频率响应描述的就是不同频率信号通过滤波器后幅度和相位的变化
  情况。频率响应是H(z)在单位圆上的取值，并且与单位脉冲响应之间是傅里叶变换
  的关系，用数学公式表示, 并且可以转为幅频响应和相频响应的乘积。可以分为 
   $$H(e^{jw})=H(z)|_{z=e^{jw}}=\frac{Y(e^{jw})}{X(e^{jw})}$$ 
<ol>
<li>低通滤波器；
</li>
<li>高通滤波器；
</li>
<li>带通滤波器；
</li>
<li>带阻滤波器；
</li>
<li>全通滤波器：主要用于改善信号的相频响应；
</li>
</ol>

</li>
</ul>

<p>滤波器的基本构成单元
</p><ol>
<li>加法单元；
</li>
<li>乘法单元；
</li>
<li>延时单元；
</li>
</ol>


</div>

<div id="outline-container-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> 设计思路</h4>
<div class="outline-text-4" id="text-1-5-1">

<ol>
<li>在具体的应用背景中提取出数字滤波器的性能参数；
</li>
<li>选择合适的滤波器类型，主要是确定使用FIR还是IIR；
</li>
<li>采用适当方法如用MATLAB计算出滤波器的系数；
</li>
<li>用一个适当的结构来表示滤波器；
</li>
<li>分析有限字长对滤波器性能的影响；
</li>
<li>用软件或硬件来实现滤波器算法；
</li>
</ol>

</div>

</div>

<div id="outline-container-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> FIR滤波</h4>
<div class="outline-text-4" id="text-1-5-2">

<p>如果一个LTI系统的单位脉冲响应长度有限，则此系统称为有限长度脉冲响应(FIR)滤
波器。因此对一个FIR滤波器，在\(n&lt;n_{1}\)和\(n&gt;n_{2}\)时h(n)=0.
</p></div>

</div>

<div id="outline-container-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> IIR滤波</h4>
<div class="outline-text-4" id="text-1-5-3">

<p>如果一个LTI系统的脉冲响应具有无线长度，则此系统称为无限长脉冲响应(IIR)滤波
器。
</p></div>

</div>

<div id="outline-container-1-5-4" class="outline-4">
<h4 id="sec-1-5-4"><span class="section-number-4">1.5.4</span> 平滑滤波</h4>
<div class="outline-text-4" id="text-1-5-4">


</div>

<div id="outline-container-1-5-4-1" class="outline-5">
<h5 id="sec-1-5-4-1"><span class="section-number-5">1.5.4.1</span> 全期平滑</h5>
<div class="outline-text-5" id="text-1-5-4-1">

<p>简单的全期平滑法是对时间数列的过去数据一个不漏的全部加以同等利用；
</p></div>

</div>

<div id="outline-container-1-5-4-2" class="outline-5">
<h5 id="sec-1-5-4-2"><span class="section-number-5">1.5.4.2</span> 移动平滑</h5>
<div class="outline-text-5" id="text-1-5-4-2">

<p>移动平滑法不考虑较远期的数据，并在加权移动平均法中给予近期资料更大的权重；
通常做法是，使用一个队列或数组作为移动窗口，有新数据时就插入队列头，当队列
数据满了，则再增加一个数据就从队尾去除一个数据；每有新数据时就用队列数据的
平均值作为输出替代。
</p><ul>
<li>优点：能够比较好的抑制随机噪声，如果窗口选择大，则最终输出数据平滑效果好；
</li>
<li>缺点：对新数据的权重比较低，导致对新输入不够敏感，比较迟滞。
</li>
</ul>

</div>

</div>

<div id="outline-container-1-5-4-3" class="outline-5">
<h5 id="sec-1-5-4-3"><span class="section-number-5">1.5.4.3</span> 指数平滑</h5>
<div class="outline-text-5" id="text-1-5-4-3">

<p>指数平滑法则兼容了全期平均和移动平均所长，不舍弃过去的数据，但是仅给与逐渐
减弱的影响权重，即随着数据的远离，赋予逐渐收敛于零的权重。
</p><ul>
<li>指数平滑的公式：
  \begin{equation}
  \label{equ-pinghua}
  s_{t} = \alpha{}.y_{t} + (1-\alpha{}).s_{t-1}
  \end{equation}
<ol>
<li>s<sub>t</sub>: 当前时刻t的平滑输出值；
</li>
<li>y<sub>t</sub>: 当前时刻t的实际输入值；
</li>
<li>s<sub>t-1</sub>: 上一时刻t-1的平滑值；
</li>
<li>&alpha;: 平滑比例常数，取值范围[0, 1]
</li>
</ol>

<p>  由式子<a href="#equ-pinghua">equ-pinghua</a>可知：
</p><ol>
<li>s<sub>t</sub>是y<sub>t</sub>和s<sub>t-1</sub>的加权算术平均数，随着&alpha;取值的大小变化，决定
     y<sub>t</sub>和s<sub>t-1</sub>对s<sub>t</sub>的影响程度，当&alpha;取1时，\(s_{t}=y_{t}\); 当取0
     时，\(s_{t}=s_{t-1}\).
</li>
<li>s<sub>t</sub>具有逐期追溯性质，可探源至s<sub>t-(t-t)</sub>为止。包括全部数据，其过程中，
     平滑常数以指数形式递减，所以称为指数平滑法。如果能够找到y<sub>1</sub>以前的历
     史数据，那么初始值s<sub>1</sub>的确定是可行的，数据较少时可以用全期平均，移动
     平均法；数据较多时，可以用最小二乘法。但不能使用指数平滑法本身确定初始
     值，因为数据会匮竭。如果仅有从y1开始的数据，那么确定初始值的方法有：
<ol>
<li>取s<sub>1</sub>等于y<sub>1</sub>；
</li>
<li>待积累若干数据后，取s<sub>1</sub>等于前面若干数据的简单算术平均数，如：
        \(s_{1}=（y_{1}+ y_{2}+y_{3}）/3\)等等。 
</li>
</ol>

</li>
</ol>

</li>
<li>一次指数平滑：设时间序列为\(y_{1}, y_{2}, ..., y_{t}...\)，则一次指数平滑
  公式如式<a href="#equ-pinghua">equ-pinghua</a>.通过展开可以有
  \begin{equation}
  \label{equ-pinghuazk}
  s_{t} = \alpha.\sum_{j=0}^{t-1}(1-\alpha)^{j}y_{t-j}+(1-\alpha)^{t}s_{0}
  \end{equation}
  由于\(0&lt;\alpha&lt;1\), 当\(t\Rightarrow \infty\)时，
  \((1-\alpha)^{t}\Rightarrow 0\)，式子<a href="#equ-pinghuazk">equ-pinghuazk</a>变为
  \begin{equation}
  s_{t} = \alpha\sum_{j=0}^{\infty}(1-\alpha)^{j}y_{t-j}
  \end{equation}
  由此可见，s<sub>t</sub>实际上是\(y_{t}, y_{t-1}...\)的加权平均，加权系数分别为
  \(\alpha, \alpha(1-\alpha), \alpha(1-\alpha)^{2}...\)是按照几何级数递减。
  越近的数据，权重越大，越远的数据，权重越小，且权重之和等于1
  \begin{equation}
  \alpha\sum_{j=0}^{\infty}(1-\alpha)^{j} = 1
  \end{equation}
  因为加权系数符合指数规律，且又具有平滑数据的功能，所以称为指数平滑。
</li>
<li>二次指数平滑：
  当时间序列没有明显的趋势变动时，使用第t周期一次指数平滑就能直接预测第t+1
  期之值。但当时间序列的变动出现直线趋势时，用一次指数平滑法来预测仍存在着
  明显的滞后偏差。因此，也需要进行修正。 修正的方法也是在一次指数平滑
  的基础上再作二次指数平滑，利用滞后偏差的规律找出曲线的发展方向和发展趋势，
  然后建立直线趋势预测模型。故称为二次指数平滑法。
  设一次指数平滑为\(s_{t}\)，则二次指数平滑\(s_{t}^{(2)}\)的计算公式为
  \begin{equation}
  s_{t}^{(2)} = \alpha{}s_{t}^{(1)}+(1-\alpha)s_{t-1}^{(2)} 
  \end{equation}
  若y<sub>t</sub>从某时刻开始具有直线趋势，且认为未来时期亦按此直线趋势变化，则可以
  用二次指数平滑。
</li>
<li>三次指数平滑：
  若时间序列的变动呈现出二次曲线趋势，则需要用三次指数平滑法。三次指数平滑
  是在二次指数平滑的基础上再进行一次平滑，其计算公式为
  \begin{equation}
  s_{t}^{(3)}=\alpha{}s_{t}^{(2)}+(1-\alpha)s_{t-1}^{(3)}
  \end{equation}
</li>
<li>指数平滑系数：指数平滑法的计算中，关键是 的取值大小，但 的取值又容易受主
  观影响，因此合理确定 的取值方法十分重要，一般来说，如果数据波动较大， 值
  应取大一些，可以增加近期数据对预测结果的影响。如果数据波动平稳， 值应取小
  一些。经验判断法：
<ol>
<li>当时间序列呈现较稳定的水平趋势时，应选较小的 值，一般可在0.05～0.20之间取值；
</li>
<li>当时间序列有波动，但长期趋势变化不大时，可选稍大的 值，常在0.1～0.4之间取值；
</li>
<li>当时间序列波动很大，长期趋势变化幅度较大，呈现明显且迅速的上升或下降趋
     势时，宜选择较大的 值，如可在0.6～0.8间选值，以使预测模型灵敏度高些，能迅速跟上数据的变化；
</li>
<li>当时间序列数据是上升（或下降）的发展趋势类型， 应取较大值，在0.6~1之间。 
</li>
</ol>

</li>
</ul>

</div>
</div>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 采样重构</h3>
<div class="outline-text-3" id="text-1-6">


</div>

<div id="outline-container-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> 频率</h4>
<div class="outline-text-4" id="text-1-6-1">

<ul>
<li>模拟频率f：每秒经历多少个周期，单位Hz，即1/s；
</li>
<li>模拟角频率Ω：每秒经历多少弧度，单位rad/s；
</li>
<li>数字频率w：每个采样点间隔之间的弧度，单位rad。
</li>
<li>关系：\(Ω = 2\pi{}f\), \(w = ΩT\), 将数字频率和模拟频率联系起来的是采样
  频率即\(w=2\pi{}f/f_{s}\), 即数字频率可以看做归一化的模拟频率乘以\(2\pi\)
</li>
</ul>

</div>

</div>

<div id="outline-container-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> 采样</h4>
<div class="outline-text-4" id="text-1-6-2">

<ul>
<li>采样定理：如果采样频率\(F_{s}\)大于有限带宽信号\(x_{a}(t)\)带宽\(F_{D}\)
  的2倍即 $$F_{s}&gt;2F_{D}$$ 则该信号可以由它的采样值\(x(n)=x_{a}(nT_{s})\)重
  构，否则就会在x(n)中产生混叠。对该有限带宽模拟信号的2F<sub>D</sub>就称为奈奎斯特
  频率。
</li>
</ul>

</div>

</div>

<div id="outline-container-1-6-3" class="outline-4">
<h4 id="sec-1-6-3"><span class="section-number-4">1.6.3</span> 重构</h4>
<div class="outline-text-4" id="text-1-6-3">

<p>当我们以合适的采样频率\(F_{s}\)采样到若干样本点x(n)后，这些样本点x(n)的频域
实际上是其模拟信号x(t)的频谱的重复，所以要从x(n)恢复x(t)只需要经过一个低通
滤波器就能完整的恢复x(t)，理论上可以使用sinc(t)函数, 然而实际使用中不方便.
\begin{equation}
sinc(t) = \frac{sin(\pi{}t)}{\pi{}t}
\end{equation}
重构数学描述如下
\begin{equation}
x(t) = \sum_{-\infty}^{\infty}x(n)sinc[F_{s}(t-nT_{s})]
\end{equation}
</p><ul>
<li>零阶保持器内插(ZOH)：每个样本值将在整个采样周期中保持，知道收到下一个样本
  为止，如下, 重构后，还需要再做一个滤波才能有略好的效果。或者可以理解为前
  后两个采样点之间的数据等于前一个采样点的数据。输出信号是阶梯波，含有高次
  谐波，相位滞后。
  $$
  h(t) = 
  \begin{cases}
  1, 0<=t<=T_{s}\\ 0, other
  \end{cases}
  $$ 
</li>
<li>一阶保持器内插(FOH)：相邻的两个样本之间用直线连接，同样需要一个后段滤波器。
  或者可以理解为前后两点之间线性插值。
  $$
  h(t) = 
  \begin{cases}
  1+\frac{t}{T}, 0 <t<T_{s}\\ 1-\frac{t}{T}, T_{s}<=t<=2T_{s}\\0, other
  \end{cases}
  $$
</li>
<li>三次样条内插：
</li>
</ul>

</div>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 小波变换</h2>
<div class="outline-text-2" id="text-2">

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2016-05-25 00:02:27 中国标准时间</p>
<p class="author">Author: 比克曼</p>
<p class="creator">Org version 7.8.11 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
