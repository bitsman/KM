#+title: 百科知识
#+author: 比克曼
#+latex_class: org-latex-pdf 
#+latex: \newpage 

* GPS
- 地球经纬线：地轴是一根通过地球南北极和地球中心的假想线，在地球中腰画一个与地轴垂直的大圆圈，使圆圈的每个点都和南北极的
  距离相等，这个圆圈就叫做“赤道”，在赤道的南北两边，画出许多和赤道平行的圆圈叫纬线，赤道定为纬度零度，向南向北各90°，
  北极就是北纬90°，南极就是南纬90°；从北极点到南极点，画出许多南北方向的与地球赤道垂直的大圆圈，叫做经度，国际上规定以
  通过英国伦敦近郊的格林尼治天文台的经线作为计算经度的起点，即经度零度零分零秒，也称“本初子午线”；在它东面的为东经，共
  180度，在它西面的为西经，共180度；因为地球是圆的，所以东经180度和西经180度的经线是同一条经线；规定180度经线为“国
  际日期变更线”。为了避免同一地区使用两个不同的日期，国际日期变线在遇陆地时略有偏离；每一经度和纬度还可以再细分为60分，
  每一分再分为60秒以及秒的小数。利用经纬线，我们就可以确定地球上每一个地方的具体位置，并且把它在地图或地球仪上表示出来；
  经度和纬度都是一种角度。
- 经度: 是个两面角，是两个经线平面的夹角。因所有经线都一样长，为度量经度选取一个起点面(本初子午线),本初子午线平面是起点
  面，终点面是本地经线平面,某一点的经度，就是该点所在的经线平面与本初子午线平面间的夹角。
- 纬度：是个线面角。起点面是赤道平面，线是本地的地面法线。所谓法线，即垂直于参考扁球体表面的线；某地的纬度就是该地的法线
  与赤道平面之间的夹角。纬度数值在0至30度之间的地区称为低纬地区，纬度数值在30至60度之间的地区称为中纬地区，纬度数值在60
  至90度之间的地区称为高纬地区。  
** 经纬度转换
- 度转度分秒
  如何将度(DDD)：108.90593度换算成“度分秒(DMS)“，东经E 108度54分22.2秒?转换方法是将108.90593整数位不变取108(度),用
  0.90593*60=54.3558,取整数位54(分),0.3558*60=21.348再取整数位21(秒),故转化为108度54分21秒. 
- 度分秒转度
  同样将度分秒(DMS):东经E 108度54分22.2秒 换算成度(DDD)的方法如下:108度54分22.2秒=108+(54/60)+(22.2/3600)=108.90616度；
  因为计算时小数位保留的原因，导致正反计算存在一定误差，但误差影响不是很大。1秒的误差就是几米的样子。 
** 经纬度转换米
- 子午线总长度大约L=40008km；
- 赤道半径 = 大约6378.140km；
- 极半径 = 大约6356.755km；
- 地球平均半径 = 大约6371.004km；
- 纬度1度 = (L/2)/180=大约111km ;
- 纬度1分 = 111km/60 = 大约1.85km ;
- 纬度1秒 = 1.85km/60 = 大约30.9m;  
** 任意两点的经纬度计算两点距离
地球是一个近乎标准的椭球体，它的赤道半径为6378.140千米，极半径为 6356.755千米，平均半径6371.004千米。如果我们假设地球是
一个完美的球体，那么它的半径就是地球的平均半径，记为R。如果以0度经线为基 准，那么根据地球表面任意两点的经纬度就可以计算
出这两点间的地表距离（这里忽略地球表面地形对计算带来的误差，仅仅是理论上的估算值）。设第一点A的经 纬度为(LonA, LatA)，第
二点B的经纬度为(LonB, LatB)，按照0度经线的基准，东经取经度的正值(Longitude)，西经取经度负值(-Longitude)，北纬取90-纬度值
(90- Latitude)，南纬取90+纬度值(90+Latitude)，则经过上述处理过后的两点被计为(MLonA, MLatA)和(MLonB, MLatB)。那么根据三角
推导，可以得到计算两点距离的如下公式：
#+begin_src c
    C = sin(MLatA)*sin(MLatB)*cos(MLonA-MLonB) + cos(MLatA)*cos(MLatB)
    Distance = R*Arccos(C)*Pi/180
#+end_src
这里，R和Distance单位是相同，如果是采用6371.004千米作为半径，那么Distance就是千米为单位，如果要使用其他单位，比如mile，
还需要做单位换算，1千米=0.621371192mile; 如果仅对经度作正负的处理，而不对纬度作90-Latitude(假设都是北半球，南半球只有澳
洲具有应用意义)的处理，那么公式将是： 
#+begin_src c
    C = sin(LatA)*sin(LatB) + cos(LatA)*cos(LatB)*cos(MLonA-MLonB)
    Distance = R*Arccos(C)*Pi/180
#+end_src
以上通过简单的三角变换就可以推出。如果三角函数的输入和输出都采用弧度值，那么公式还可以写作：
#+begin_src c
C = sin(LatA*Pi/180)*sin(LatB*Pi/180) + cos(LatA*Pi/180)*cos(LatB*Pi/180)*cos((MLonA-MLonB)*Pi/180)
Distance = R*Arccos(C)*Pi/180
#+end_src
也就是：
#+begin_src c
C = sin(LatA/57.2958)*sin(LatB/57.2958) + cos(LatA/57.2958)*cos(LatB/57.2958)*cos((MLonA-MLonB)/57.2958)
Distance = R*Arccos(C) = 6371.004*Arccos(C) kilometer = 0.621371192*6371.004*Arccos(C) mile = 3958.758349716768*Arccos(C) mile
#+end_src
在实际应用当中，一般是通过一个个体的邮政编码来查找该邮政编码对应的地区中心的经纬度，然 后再根据这些经纬度来计算彼此的距
离，从而估算出某些群体之间的大致距离范围(比如酒店旅客的分布范围-各个旅客的邮政编码对应的经纬度和酒店的经纬度所 计算的距
离范围-等等)，所以，通过邮政编码查询经纬度这样一个数据库是一个很有用的资源。 附：C#代码： 
#+begin_src c++
private const double EARTH_RADIUS = 6378.137;//地球半径
private static double rad(double d)
{
   return d * Math.PI / 180.0;
}

public static double GetDistance(double lat1, double lng1, double lat2, double lng2)
{
   double radLat1 = rad(lat1);
   double radLat2 = rad(lat2);
   double a = radLat1 - radLat2;
   double b = rad(lng1) - rad(lng2);
   double s = 2 * Math.Asin(Math.Sqrt(Math.Pow(Math.Sin(a/2),2) +
    Math.Cos(radLat1)*Math.Cos(radLat2)*Math.Pow(Math.Sin(b/2),2)));
   s = s * EARTH_RADIUS;
   s = Math.Round(s * 10000) / 10000;
   return s;
}
#+end_src

