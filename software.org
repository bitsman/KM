#+title: 软件
#+author: 比克曼
#+latex_class: org-latex-pdf 
#+toc: tables 
#+latex: \clearpage\pagenumbering{arabic} 
#+options: h:4 
#+startup: overview

* 编程语言
** C语言
*** 宏操作
- 从注释来看是把x转换成字符串。
  #+begin_src c
    /*
     ,* Macros to transform values
     ,* into environment strings.
     ,*/
    #define XMK_STR(x)  #x
    #define MK_STR(x)   XMK_STR(x)
  #+end_src

  找到了相关的资料，解读了这个define，还顺便认识了另外两个不常用的
  define
  #+begin_src c
    #define Conn(x,y) x##y
    #define ToChar(x) #@x
    #define ToString(x) #x
  #+end_src

  x##y表示什么？表示x连接y，举例说：
  #+begin_src c
    int  n = Conn(123,456);  //结果就是n=123456;
    char* str = Conn("asdf", "adf")//结果就是 str = "asdfadf";
  #+end_src

  再来看#@x，其实就是给x加上单引号，结果返回是一个const char。举例说：
  char a = ToChar(1);结果就是a='1';做个越界试验char a=ToChar(123);结
  果是a='3'; 但是如果你的参数超过四个字符，编译器就给给你报错了！
  error C2015: too many characters in constant; 最后看看#x,估计你也明
  白了，他是给x加双引号
  #+begin_src c
    char* str = ToString(123132);//就成了str="123132";
  #+end_src
- 宏调试接口
  #+begin_src c
    #pragma diag_suppress 174 //抑制警告
    #ifdef DEBUG
    #define printfdbg printf
    #else
    #define printfdbg /                             \
        /printfdbg 
    #endif
  #+end_src
- 可变参宏函数
  #+BEGIN_SRC c 
    //可变参宏函数定义
    #define HAL_FUN(FUN_NAME, ...)   \
        FUN_NAME(__VA_ARGS__);
    //1参数函数定义
    void funTest1(int a)
    {
        printf ("a:%d\n", a);
    }
    //2参数函数定义
    void funTest1(int a, int b)
    {
        printf ("sum:%d\n", a+b);
    }
    //调用实例
    int main(int argc, char* argv[])
    {
        HAL_FUN(funTest1, 2);
        HAL_FUN(funTest1, 1, 3);
        return 0;
    }
  #+END_SRC
*** 位操作
- 将最右侧0改为1：
  #+begin_src c
    x|(x+1) 
  #+end_src
- 计算绝对值
  #+begin_src c
    int abs( int x ) 
    {
        int y ;
        y = x >> 31 ;
        return (x^y)-y ;//or: (x+y)^y
    }
  #+end_src
- 符号函数
  #+begin_src c
    int sign(int x)
    {
        return (x>>31) | (unsigned(-x))>>31 ;//x=-2^31时失败(^为幂)
    }
  #+end_src
  1. sign(x) = -1, 则x<0;
  2. sign(x) = 0, 则x==0 ;
  3. sign(x) = 1, 则x>0
- 三值比较
  #+begin_src c
    int cmp( int x, int y )
    {
        return (x>y)-(x-y) ;
    }
  #+end_src
  1. cmp(x,y) = -1, 则x<y;
  2. cmp(x,y) = 0, 则x==y;
  3. cmp(x,y) = 1, 则x > y；
- 不使用第三方交换x,y
  #+begin_src c
    x ^= y ; y ^= x ; x ^= y ;
    x = x+y ; y = x-y ; x = x-y ;
    x = x-y ; y = y+x ; x = y-x ;
    x = y-x ; x = y-x ; x = x+y ; 
  #+end_src
- 统计1位的数量
  #+begin_src c
    int pop(unsigned x)
    {
        x = x-((x>>1)&0x55555555) ;
        x = (x&0x33333333) + ((x>>2) & 0x33333333 ) ;
        x = (x+(x>>4)) & 0x0f0f0f0f ;
        x = x + (x>>8) ;
        x = x + (x>>16) ;
        return x & 0x0000003f ;
    }
  #+end_src
- 位反转
  #+begin_src c
    unsigned rev(unsigned x)
    {
        x = (x & 0x55555555) << 1 | (x>>1) & 0x55555555 ;
        x = (x & 0x33333333) << 2 | (x>>2) & 0x33333333 ;
        x = (x & 0x0f0f0f0f) << 4 | (x>>4) & 0x0f0f0f0f ;
        x = (x<<24) | ((x&0xff00)<<8) | ((x>>8) & 0xff00) | (x>>24) ;
        return x ;
    }
  #+end_src
- 二进制码到GRAY码的转换
  #+begin_src c
    unsigned B2G(unsigned B )
    {
        return B ^ (B>>1) ;
    }
  #+end_src
- GRAY码到二进制码
  #+begin_src c
    unsigned G2B(unsigned G)
    {
        unsigned B ;
        B = G ^ (G>>1) ;
        B = G ^ (G>>2) ;
        B = G ^ (G>>4) ;
        B = G ^ (G>>8) ;
        B = G ^ (G>>16) ;
        return B ;
    }
  #+end_src
*** 嵌入式
- printf调试：可以如下步骤
  #+begin_src c
    #include "uart.h"//串口发送单个字符的API
    #include "stdio.h"//里面有FILE结构体声明
    #pragma import(__use_no_semihosting_swi)//半主机模式
    struct __FILE//stdio.h里面的FILE结构体声明需要
    {
      int handle;
    };
    FILE __stdout, __stderr;//选用，如果需要分别输出

    int fputc(int ch, FILE* f)//printf最终调用的接口
    {
      uart_put((unsigned char)ch);
      return ch;
    }
  #+end_src  
** JAVA语言
** PYTHON语言
*** base
- 字符串转换为变量。
  #+begin_src python
    var = "This is a string"
    varName = 'var'
    s= locals()[varName]
    s2=vars()[varName]
    print(s)
    print(s2)
    print(eval(varName))
  #+end_src 
- 添加个人库: 比如当前工作路径下有./lib/File/filecsv.py , 然后就可以直接使
  用filecsv里面的函数了。
  #+begin_src python
    sys.path.append('./lib')
    from File.file_csv import *
  #+end_src
- 重新载入模块：比如重新加载filecsv.py。
  1. 导入sys，imp库，import sys，imp
  2. 查看已经导入的库，sys.modules
  3. 找到filecsv库的字符
  4. 重新导入模块，imp.reload(sys.modules['filecsv'])
*** numpy
- array矩阵的max和min静态属性：比如array矩阵data=array([[1, 5, 3],
  [8, 6, 1], [9, 0, 4], [4, 6, 5]]), data.min(0) 和data.max(0)是从每
  列中获取的min和max，组成一个向量，data.min(1) 和data.max(1)是从每行
  中获得min和max； 
- 指数e：numpy.exp()可以表示，但是是函数，math.exp()也是，scipy.exp()
  也是，numpy.e和math.e和scipy.e则是一个float型量了。 
- 复数：可以表示成1+3j，3和j之间不能相隔，3必须为实数不能是符号，j必
  须在3之后，也可以使用numpy.complex(1, 3)构成1+3j, 同理也就可以构成
  numpy.complex(1, numpy.pi)即\(e^{1+pi j}\)，复数的角度用
  numpy.angle()计算 
*** matplotlib
此包注意用于画图
**** 画XY轴离散点图
1. 先获得x,y的取值范围，比如x=numpy.arange(0, 10), y=numpy.arange(3,
   10), 其个数要一致； 
2. 倒入画图包：import matplotlib.pyplot as plt；
3. 开始画图：plt.plot(x, y, 'o-'), 第3个参数用于对点进行标注；
4. 设置标题：plt.title('x, y test')
5. 设置X轴说明：plt.xlabel('x label')
6. 设置y轴说明：plt.ylabel('y label')
7. 显示图：plt.show()
* 状态机和信号量
** 断言
#+BEGIN_SRC c -n
  #ifdef NF_NDEBUG
  #define NF_ASSERT(_exp) ((void)0)
  #else
  #define NF_ASSERT(_exp) ((_exp) ? (void)0 :
              NF_Assert_Failed((const char * )__FILE__, __LINE__))
  extern void NF_Assert_Failed(const char * file, NF_Int32U line);
  #endif
#+END_SRC 
** 信号量
*** 信号值
#+BEGIN_SRC c -n 
  typedef uint32_t SignalValue_T;
#+END_SRC 
*** 信号名
#+BEGIN_SRC c -n 
  typedef const char* SignalName_T;
#+END_SRC
*** 信号ID
#+BEGIN_SRC c -n 
  typedef uint32_t SignalID_T;
#+END_SRC
*** 信号对象
#+BEGIN_SRC c -n 
  typedef struct _sig
  {
      SignalName_T  Name;
      SignalValue_T Value;
  }Signal_T;
#+END_SRC
*** 信号存储表
#+BEGIN_SRC c -n
  #define MAX_SIGNAL_NUM    50  
  static Signal_T Signal_SigList[MAX_SIGNAL_NUM] = {0};
  static uint32_t Signal_SigListCnt = 0;
#+END_SRC
*** 信号内部操作
- 信号搜索
  #+BEGIN_SRC c -n 
    //按信号名在表中查找信号对象
    Signal_T* Signal_Search(SignalName_T name, SignalID_T* id_ret)
    {
        uint32_t i;
  
        //信号名不能为空
        NF_ASSERT( name != NULL_PTR );
  
        for (i = 0; i < Signal_SigListCnt; i ++)
        {
            if ( strcmp(Signal_SigList[i].Name, name) == 0 )
            {
                //通过回调参数返回ID号
                if (id_ret != NULL_PTR)
                {
                    *id_ret = i;
                }
  
                return &(Signal_SigList[i]);
            }
        }
        //没有找到，返回空指针
        return NULL_PTR;
    }
  #+END_SRC
- 创建信号
  #+BEGIN_SRC c -n 
    Signal_T* Signal_Create(SignalName_T name, SignalValue_T val, SignalID_T* id_ret)
    {
        //信号名不能为空
        NF_ASSERT( name != NULL_PTR );
        if (Signal_SigListCnt < MAX_SIGNAL_NUM)
        {
            Signal_SigList[Signal_SigListCnt].Name  = name;
            Signal_SigList[Signal_SigListCnt].Value = val;
            Signal_SigListCnt ++;
            //通过回调参数返回ID号
            if (id_ret != NULL_PTR)
            {
                ,*id_ret = Signal_SigListCnt - 1;
            }
            return &(Signal_SigList[Signal_SigListCnt - 1]);
        }
        else
        {
            //信号列表满，创建失败
            //此时应加大头文件中最大信号数量宏MAX_SIGNAL_NUM
            return NULL_PTR;
        }
    }
  #+END_SRC
*** 信号操作API
- 通过信号名设置值
  #+BEGIN_SRC c -n
    SignalID_T Signal_Set(SignalName_T name, SignalValue_T val)
    {
        Signal_T* sig = NULL_PTR;
        SignalID_T id;
        //信号名不能为空
        ASSERT( name != NULL_PTR );
        sig = Signal_Search(name, &id);
        if (sig != NULL_PTR)
        {
            sig->Value = val;
            return id;
        }
        else
        {
            sig = Signal_Create(name, val, &id);
            //断言失败则信号列表满，需增大NF_MAX_SIGNAL_NUM
            ASSERT( sig != NULL_PTR );
            return id;
        }
    }
  #+END_SRC
- 通过信号ID设置值
  #+BEGIN_SRC c -n 
    void Signal_SetID(SignalID_T id, SignalValue_T val)
    {
        //ID号需有效
        ASSERT( id < Signal_SigListCnt );
        if (id < Signal_SigListCnt)
        {
            Signal_SigList[id].Value = val;
        }
    }
  #+END_SRC
- 通过信号名获取值
  #+BEGIN_SRC c -n
    SignalValue_T Signal_Get(SignalName_T name)
    {
        Signal_T* sig = NULL_PTR;
        //信号名不能为空
        ASSERT( name != NULL_PTR );
        sig = Signal_Search(name, NULL_PTR);

        if (sig != NULL_PTR)
        {
            //搜索成功返回信号值
            return sig->Value;
        }
        else
        {
            //搜索失败返回0
            return 0;
        }
    }
  #+END_SRC
- 通过信号ID获取值
  #+BEGIN_SRC c -n 
    SignalValue_T Signal_GetID(SignalID_T id)
    {
        //ID号需有效
        ASSERT( id < Signal_SigListCnt );

        if (id < Signal_SigListCnt)
        {
            return Signal_SigList[id].Value;
        }
    }
  #+END_SRC
** 状态机
*** 状态机
#+BEGIN_SRC c -n
  typedef struct _sta_machine
  {
      State_T     State;
      FSM_Name_T  Name;
  }FSM_T;

#+END_SRC
*** 状态名称
#+BEGIN_SRC c -n 
 typedef const char* FSM_Name_T;
#+END_SRC
*** 状态处理函数
#+BEGIN_SRC c -n 
  typedef void (*FSM_Handler_T)(FSM_T* me, SignalName_T name, SignalValue_T val);
#+END_SRC
*** 状态定义
#+BEGIN_SRC c -n
  typedef struct _sta
  {
      FSM_Handler_T Dispatch;
      FSM_Name_T    Name;
  }State_T;
#+END_SRC
*** 状态转换函数
- 检查信号状态并派发给状态机
  #+BEGIN_SRC c -n 
    void FSM_CheckSignal(FSM_T* me, SignalName_T name)
    {
        ASSERT( me != NULL_PTR );
        me->State.Dispatch(me, name, Signal_Get(name));
    }
  #+END_SRC
- 转换状态机状态
  #+BEGIN_SRC c -n
    void FSM_Translate(FSM_T* me, State_T state) 
    {
        ASSERT( me != NULL_PTR );
        me->State = state;
    }   
  #+END_SRC
** 应用
*** 状态机转换
#+BEGIN_SRC plantuml :exports results :file ./img/stmch_app.png
  state IDLE
  state QDOWN
  state QEDOWN

  IDLE -right-> QDOWN: Q Press

  QDOWN --> IDLE: Q Release
  QDOWN -right-> QEDOWN: E Press

  QEDOWN --> QDOWN: E Release
  QEDOWN --> IDLE: Q Release
#+END_SRC 
#+CAPTION: 状态机应用
#+NAME: imgstmchapp
#+attr_latex: :placement [H] :width 0.6\textwidth
#+results:
[[file:./img/stmch_app.png]]

*** 源码
#+BEGIN_SRC c -n
  //GetKeyState:windows api监测键盘按键
  #define IS_KEY_PRESS(_key) ((GetKeyState(_key) >= 0) ? Bool_False : Bool_True )

  //信号产生者
  void Test_Key_Process(void)
  {
      if ( IS_KEY_PRESS('Q') ){
          Signal_Set("key_q_press", 1);
      }
      else{
          Signal_Set("key_q_press", 0);
      }

      if ( IS_KEY_PRESS('E') ){
          Signal_Set("key_e_press", 1);
      }
      else{
          Signal_Set("key_e_press", 0);
      }
  }

  //状态机对象
  FSM_T Test_FSM_QandE;

  //状态机的三个状态处理函数
  //IDLE状态处理函数
  void Test_FSM_QandE_IDLE(FSM_T* me, SignalName_T name, SignalValue_T val)
  {
      if ( FSM_NameIs(name, "key_q_press") )
      {
          if ( val == 1 )
          {
              FSM_TRAN(Test_FSM_QandE_QDOWN);
              printf("Test_FSM_QandE State Translate : IDLE --> QDOWN\n");
          }
      }
  }

  //QDOWN状态处理函数
  void Test_FSM_QandE_QDOWN(FSM_T* me, SignalName_T name, SignalValue_T val)
  {
      if ( FSM_NameIs(name, "key_e_press") )
      {
          if ( val == 1 )
          {
              FSM_TRAN(Test_FSM_QandE_QEDOWN);
              printf("Test_FSM_QandE State Translate : QDOWN --> QEDOWN\n");
          }
      }
      else if( FSM_NameIs(name, "key_q_press") )
      {
          if ( val == 0 )
          {
              FSM_TRAN(Test_FSM_QandE_IDLE);
              printf("Test_FSM_QandE State Translate : QDOWN --> IDLE\n");
          }
      }
  }

  //QEDOWN状态处理函数
  void Test_FSM_QandE_QEDOWN(FSM_T* me, SignalName_T name, SignalValue_T val)
  {
      if ( FSM_NameIs(name, "key_e_press") )
      {
          if ( val == 0 )
          {
              FSM_TRAN(Test_FSM_QandE_QDOWN);
              printf("Test_FSM_QandE State Translate : QEDOWN --> QDOWN\n");
          }
      }
      else if( FSM_NameIs(name, "key_q_press") )
      {
          if ( val == 0 )
          {
              FSM_TRAN(Test_FSM_QandE_IDLE);
              printf("Test_FSM_QandE State Translate : QEDOWN --> IDLE\n");
          }
      }
  }

  int main(void)
  {
      //初始化状态机
      FSM_Translate(&Test_FSM_QandE, FSM_State(Test_FSM_QandE_IDLE));

      for (;;)
      {
          Test_Key_Process();
          FSM_CheckSignal(&Test_FSM_QandE, "key_q_press");
          FSM_CheckSignal(&Test_FSM_QandE, "key_e_press");
      }
  }
#+END_SRC
