#+title: 软件
#+author: 比克曼
#+latex_class: org-latex-pdf 
#+toc: tables 
#+latex: \clearpage\pagenumbering{arabic} 
#+options: h:4 
#+startup: overview

* 编程语言
** c
*** 宏操作
- 从注释来看是把x转换成字符串。
  #+begin_src c
    /*
     ,* Macros to transform values
     ,* into environment strings.
     ,*/
    #define XMK_STR(x)  #x
    #define MK_STR(x)   XMK_STR(x)
  #+end_src

  找到了相关的资料，解读了这个define，还顺便认识了另外两个不常用的
  define
  #+begin_src c
    #define Conn(x,y) x##y
    #define ToChar(x) #@x
    #define ToString(x) #x
  #+end_src

  x##y表示什么？表示x连接y，举例说：
  #+begin_src c
    int  n = Conn(123,456);  //结果就是n=123456;
    char* str = Conn("asdf", "adf")//结果就是 str = "asdfadf";
  #+end_src

  再来看#@x，其实就是给x加上单引号，结果返回是一个const char。举例说：
  char a = ToChar(1);结果就是a='1';做个越界试验char a=ToChar(123);结
  果是a='3'; 但是如果你的参数超过四个字符，编译器就给给你报错了！
  error C2015: too many characters in constant; 最后看看#x,估计你也明
  白了，他是给x加双引号
  #+begin_src c
    char* str = ToString(123132);//就成了str="123132";
  #+end_src
- 宏调试接口
  #+begin_src c
    #pragma diag_suppress 174 //抑制警告
    #ifdef DEBUG
    #define printfdbg printf
    #else
    #define printfdbg /                             \
        /printfdbg 
    #endif
  #+end_src
- 可变参宏函数
  #+BEGIN_SRC c 
    //可变参宏函数定义
    #define HAL_FUN(FUN_NAME, ...)   \
        FUN_NAME(__VA_ARGS__);
    //1参数函数定义
    void funTest1(int a)
    {
        printf ("a:%d\n", a);
    }
    //2参数函数定义
    void funTest1(int a, int b)
    {
        printf ("sum:%d\n", a+b);
    }
    //调用实例
    int main(int argc, char* argv[])
    {
        HAL_FUN(funTest1, 2);
        HAL_FUN(funTest1, 1, 3);
        return 0;
    }
  #+END_SRC
*** 位操作
- 将最右侧0改为1：
  #+begin_src c
    x|(x+1) 
  #+end_src
- 计算绝对值
  #+begin_src c
    int abs( int x ) 
    {
        int y ;
        y = x >> 31 ;
        return (x^y)-y ;//or: (x+y)^y
    }
  #+end_src
- 符号函数
  #+begin_src c
    int sign(int x)
    {
        return (x>>31) | (unsigned(-x))>>31 ;//x=-2^31时失败(^为幂)
    }
  #+end_src
  1. sign(x) = -1, 则x<0;
  2. sign(x) = 0, 则x==0 ;
  3. sign(x) = 1, 则x>0
- 三值比较
  #+begin_src c
    int cmp( int x, int y )
    {
        return (x>y)-(x-y) ;
    }
  #+end_src
  1. cmp(x,y) = -1, 则x<y;
  2. cmp(x,y) = 0, 则x==y;
  3. cmp(x,y) = 1, 则x > y；
- 不使用第三方交换x,y
  #+begin_src c
    x ^= y ; y ^= x ; x ^= y ;
    x = x+y ; y = x-y ; x = x-y ;
    x = x-y ; y = y+x ; x = y-x ;
    x = y-x ; x = y-x ; x = x+y ; 
  #+end_src
- 统计1位的数量
  #+begin_src c
    int pop(unsigned x)
    {
        x = x-((x>>1)&0x55555555) ;
        x = (x&0x33333333) + ((x>>2) & 0x33333333 ) ;
        x = (x+(x>>4)) & 0x0f0f0f0f ;
        x = x + (x>>8) ;
        x = x + (x>>16) ;
        return x & 0x0000003f ;
    }
  #+end_src
- 位反转
  #+begin_src c
    unsigned rev(unsigned x)
    {
        x = (x & 0x55555555) << 1 | (x>>1) & 0x55555555 ;
        x = (x & 0x33333333) << 2 | (x>>2) & 0x33333333 ;
        x = (x & 0x0f0f0f0f) << 4 | (x>>4) & 0x0f0f0f0f ;
        x = (x<<24) | ((x&0xff00)<<8) | ((x>>8) & 0xff00) | (x>>24) ;
        return x ;
    }
  #+end_src
- 二进制码到GRAY码的转换
  #+begin_src c
    unsigned B2G(unsigned B )
    {
        return B ^ (B>>1) ;
    }
  #+end_src
- GRAY码到二进制码
  #+begin_src c
    unsigned G2B(unsigned G)
    {
        unsigned B ;
        B = G ^ (G>>1) ;
        B = G ^ (G>>2) ;
        B = G ^ (G>>4) ;
        B = G ^ (G>>8) ;
        B = G ^ (G>>16) ;
        return B ;
    }
  #+end_src
*** 嵌入式
- printf调试：可以如下步骤
  #+begin_src c
    #include "uart.h"//串口发送单个字符的API
    #include "stdio.h"//里面有FILE结构体声明
    #pragma import(__use_no_semihosting_swi)//半主机模式
    struct __FILE//stdio.h里面的FILE结构体声明需要
    {
      int handle;
    };
    FILE __stdout, __stderr;//选用，如果需要分别输出

    int fputc(int ch, FILE* f)//printf最终调用的接口
    {
      uart_put((unsigned char)ch);
      return ch;
    }
  #+end_src  
** java
** python
*** base
- 字符串转换为变量。
  #+begin_src python
    var = "This is a string"
    varName = 'var'
    s= locals()[varName]
    s2=vars()[varName]
    print(s)
    print(s2)
    print(eval(varName))
  #+end_src 
- 添加个人库: 比如当前工作路径下有./lib/File/filecsv.py , 然后就可以直接使
  用filecsv里面的函数了。
  #+begin_src python
    sys.path.append('./lib')
    from File.file_csv import *
  #+end_src
- 重新载入模块：比如重新加载filecsv.py。
  1. 导入sys，imp库，import sys，imp
  2. 查看已经导入的库，sys.modules
  3. 找到filecsv库的字符
  4. 重新导入模块，imp.reload(sys.modules['filecsv'])
*** numpy
- array矩阵的max和min静态属性：比如array矩阵data=array([[1, 5, 3],
  [8, 6, 1], [9, 0, 4], [4, 6, 5]]), data.min(0) 和data.max(0)是从每
  列中获取的min和max，组成一个向量，data.min(1) 和data.max(1)是从每行
  中获得min和max； 
- 指数e：numpy.exp()可以表示，但是是函数，math.exp()也是，scipy.exp()
  也是，numpy.e和math.e和scipy.e则是一个float型量了。 
- 复数：可以表示成1+3j，3和j之间不能相隔，3必须为实数不能是符号，j必
  须在3之后，也可以使用numpy.complex(1, 3)构成1+3j, 同理也就可以构成
  numpy.complex(1, numpy.pi)即\(e^{1+pi j}\)，复数的角度用
  numpy.angle()计算 
*** matplotlib
此包注意用于画图
**** 画XY轴离散点图
1. 先获得x,y的取值范围，比如x=numpy.arange(0, 10), y=numpy.arange(3,
   10), 其个数要一致； 
2. 倒入画图包：import matplotlib.pyplot as plt；
3. 开始画图：plt.plot(x, y, 'o-'), 第3个参数用于对点进行标注；
4. 设置标题：plt.title('x, y test')
5. 设置X轴说明：plt.xlabel('x label')
6. 设置y轴说明：plt.ylabel('y label')
7. 显示图：plt.show()
*** module
- watermark:
  #+BEGIN_SRC python
    def handle_waterprint ():
        clipboard = QApplication.clipboard()
        img = ImageGrab.grabclipboard()

        outOriginFile = "arch_origin/"+ time.strftime('%y%m%d_%H%M%S') + ".png";

        ### 判断是图片才走下面流程, 否则提示错误
        if isinstance(img, Image.Image):
            img.save(outOriginFile, 'PNG') 
            ttfFile = "msyh.ttf"
            text = "定制的文本 " + time.strftime('%Y-%m-%d %H:%M')
            ### 根据对角线角度来
            wi, he = img.size
            # 角度, 可以旋转文字
            angle = math.atan(he/wi) * 180 / math.pi 
            opacity = 0.3
            ### 保留后边颜色值参数会有蒙层
            watermark = Image.new('RGBA', img.size)  
            ### 保留后边颜色值参数会有蒙层
            # watermark = Image.new('RGBA', img.size, (255,255,255))  
            FONT = ttfFile
            ### 智能放大字体的初始大小
            size = 9
            #得到字体  
            n_font = ImageFont.truetype(FONT, size) 

            n_width, n_height = n_font.getsize(text)  
            text_box = min(watermark.size[0], watermark.size[1])  
            while (n_width+n_height <  text_box):  
                size += 2  
                n_font = ImageFont.truetype(FONT, size=size)  
                #文字逐渐放大，但是要小于图片的宽高最小值 
                n_width, n_height = n_font.getsize(text)  

            # 使用最新的字体大小
            FontShadow = ImageFont.truetype(FONT, size)

            ### 实际控制位置
            text_width = (watermark.size[0] - n_width) / 2  
            text_height = (watermark.size[1] - n_height) / 2  
            #watermark = watermark.resize((text_width,text_height), Image.ANTIALIAS)  
            #在水印层加画笔  
            draw = ImageDraw.Draw(watermark, 'RGBA') 

            expand = 5
            shapeRange = (text_width - expand, text_height - expand, text_width + n_width + expand, text_height + n_height + expand)
            draw.rectangle(shapeRange, 'black', 'white')

            expand = 5
            shapeRange = (text_width - expand, text_height - expand, text_width + n_width + expand, text_height + n_height + expand)
            draw.rectangle(shapeRange, 'black', 'white') 

            ### 类似阴影的效果
            draw.text((text_width - 1,text_height - 1),  
                      text, font=FontShadow, fill="#FFFFFF", outline = "white") 

            draw.text((text_width,text_height),  
                      text, font=n_font, fill="#CD6600")  

            additionText = "附加文本"
            border = 2
            draw.text((text_width, text_height +  n_height + expand + border),  
                      additionText, font=n_font, fill="#000000") 
            draw.text((text_width + border, text_height +  n_height + expand),  
                      additionText, font=n_font, fill="#000000") 
            draw.text((text_width, text_height +  n_height + expand - border),  
                      additionText, font=n_font, fill="#000000") 
            draw.text((text_width - border, text_height +  n_height + expand),  
                      additionText, font=n_font, fill="#000000") 
            draw.text((text_width, text_height +  n_height + expand),  
                      additionText, font=n_font, fill="#FFFFFF")  

            watermark = watermark.rotate(angle, Image.BICUBIC)  
            alpha = watermark.split()[3]  
            alpha = ImageEnhance.Brightness(alpha).enhance(opacity)  
            watermark.putalpha(alpha)  
            outFile = "arch/"+ time.strftime('%y%m%d_%H%M%S') + ".png";
            Image.composite(watermark, img, watermark).save(outFile, 'PNG')  

            ############# 下面这个似乎容易出错导致死掉
            clipboard.setImage(QImage(outFile))
            # print(clipboard)
        else:
            print("not image")
  #+END_SRC
  


